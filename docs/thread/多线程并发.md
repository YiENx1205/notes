# CAS（比较并交换-乐观锁机制-锁自旋）

## 一、概念

CAS（Compare-And-Swap）是`比较并交换`的意思，它是一条 CPU 并发原语，用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是`原子`的。

> **可以保证原子吗？可以**
>
> CAS 是一种`系统原语`，原语属于操作系统用语，原语由若干指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，由操作系统硬件来保证。

CAS机制当中使用了3个基本操作数：

- 内存地址V
- 旧的预期值E
- 计算后要修改后的新值N

当且仅当 V 值于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。

```java
return V = V == E ? N : V;
```

## 二、CAS在Java中的应用

**原子包 java.util.concurrent.atomic（锁自旋）**

这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，<strong style="color:#03468F">即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入</strong>，这只是一种逻辑上的理解。

相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072036985.png" style="zoom: 67%;" />

比如说 AtomicInteger 类就可以解决 i++ 非原子性问题，通过查看源码可以发现主要是靠 volatile 关键字和 CAS 操作来实现。

```java
public class AtomicInteger extends Number implements java.io.Serializable { 
	private volatile int value; 
	public final int get() {  
        return value; 
 	} 
	public final int getAndIncrement() { 
    	for (;;) { //CAS 自旋，一直尝试，直达成功
            int current = get(); 
            int next = current + 1; 
            if (compareAndSet(current, next)) 
                return current; 
        } 
 	} 
 	public final boolean compareAndSet(int expect, int update) { 
 		// JNI
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update); 
 	} 
}
```

## 三、CAS的问题***

### 1、 典型 ABA 问题

ABA 是 CAS 操作的一个经典问题，假设有一个变量初始值为 A，修改为 B，然后又修改为 A，这个变量实际被修改过了，但是 CAS 操作可能无法感知到。

如果是整形还好，不会影响最终结果，但如果是对象的引用类型包含了多个变量，引用没有变实际上包含的变量已经被修改，这就会造成大问题。

解决方法：在变量前加版本号，每次变量更新了就把版本号加一，结果如下：

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072041052.png" style="zoom: 33%;" />

最终结果都是 A 但是版本号改变了。

从 JDK 1.5 开始提供了`AtomicStampedReference`类，这个类的 `compareAndSe `方法首先检查`当前引用`是否等于`预期引用`，并且`当前标志`是否等于`预期标志`，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

### 2、自旋开销问题

CAS 出现冲突后就会开始`自旋`操作，如果资源竞争非常激烈，自旋长时间不能成功就会给 CPU 带来非常大的开销。

解决方案：可以考虑限制自旋的次数，避免过度消耗 CPU；另外还可以考虑延迟执行。

### 3、只能保证单个变量的原子性

当对一个共享变量执行操作时，可以使用 CAS 来保证原子性，但是如果要对多个共享变量进行操作时，CAS 是无法保证原子性的，比如需要将 i 和 j 同时加 1：

```java
i++;
j++;
```

这个时候可以使用 synchronized 进行加锁，有没有其他办法呢？有，将多个变量操作合成一个变量操作。从 JDK1.5 开始提供了`AtomicReference` 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

<br>

# AQS（抽象的队列同步器）

AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的

ReentrantLock、Semaphore、CountDownLatch

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072047099.png" alt="image-20220407204738166" style="zoom:80%;" />

它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词。state 的访问方式有三种：

- getState()
- setState()
- compareAndSetState()

AQS定义两种资源共享方式：

- Exclusive（独占，只有一个线程能执行，如 ReentrantLock）
- Share（共享，多个线程可同时执行，如 Semaphore、CountDownLatch ）。

`AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现`，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS）。

之所以没有定义成abstract ，是因为**独占模式**下只用实现 tryAcquire-tryRelease ，而**共享模式**下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。

自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：

1．isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。

2．tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 

3．tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 

4．tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。

5．tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072055382.png" alt="image-20220407205526565" style="zoom:67%;" />

<br>

# 线程的实现与创建方式

## 一、继承Thread类

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的start()实例方法。`start()方法是一个 native 方法`，它将启动一个新线程，并执行run()方法。

```java
public class ThreadTest02 {
    public static void main(String[] args) {
        // 这里是main方法，这里的代码属于主线程，在主栈中运行。
        // 新建一个分支线程对象
        MyThread t = new MyThread();
        // 启动线程
        // t.run(); // 不会启动线程，不会分配新的分支栈。（这种方式就是单线程。）
        // start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，
        // 这段代码任务完成之后，瞬间就结束了。
        // 其任务只是为了开启一个新的栈空间，
        // 只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。
        // 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。
        // run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。
        t.start();
        // 这里的代码还是运行在主线程中。
        for(int i = 0; i < 1000; i++){
            System.out.println("主线程--->" + i);
        }
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        // 编写程序，这段程序运行在分支线程中（分支栈）。
        for(int i = 0; i < 1000; i++){
            System.out.println("分支线程--->" + i);
        }
    }
}
```



## 二、实现Runnable接口

如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口。

```java
public class ThreadTest03 {
    public static void main(String[] args) {
        //创建一个可运行的对象
        //MyRunnable r = new MyRunnable();
        //将可运行的对象封装成一个线程对象
        Thread t = new Thread(new MyRunnable());
        //启动线程
        t.start();
        for(int i = 0; i < 100; i++){
            System.out.println("主线程--->" + i);
        }
    }
}

//这并不是一个线程类，是一个可运行的类，还不是一个线程
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 100; i++){
            System.out.println("分支线程--->" + i);
        }
    }
}
```



## 三、ExecutorService、Callable\<Class>、Future有返回值线程

`有返回值的任务必须实现 Callable 接口`，类似的，`无返回值的任务必须 Runnable 接口`。执行Callable 任务后，`可以获取一个 Future 的对象`，在该对象上`调用 get `就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。

这种方式的缺点：效率比较低，在获取 t 线程执行结果的时候，当前线程受阻塞，效率较低。

```java
//创建一个线程池
ExecutorService pool = Executors.newFixedThreadPool(taskSize);
// 创建多个有返回值的任务
List<Future> list = new ArrayList<Future>(); 
for (int i = 0; i < taskSize; i++) { 
    Callable c = new MyCallable(i + " "); 
    // 执行任务并获取 Future 对象
    Future f = pool.submit(c); 
    list.add(f); 
} 
// 关闭线程池
pool.shutdown(); 
// 获取所有并发任务的运行结果
for (Future f : list) { 
	// 从 Future 对象上获取任务的返回值，并输出到控制台
	System.out.println("res：" + f.get().toString()); 
}
```



```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class ThreadTest15 {
    public static void main(String[] args) throws Exception {
        // 第一步：创建一个"未来任务类"对象
        FutureTask task = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception { 
                //call()就相当于run()只不过有返回值
                return Obj;
        });
        // 创建线程对象
        Thread t = new Thread(task);
        // 启动线程
        t.start();
        // 这里是main方法，这是在主线程中。
        // 在主线程中，怎么获取t线程的返回结果？
        // get()方法的执行会导致“当前线程阻塞”
        Object obj = task.get();
        System.out.println("线程执行结果:" + obj);
        // main方法这里的程序要想执行必须等待get()方法的结束
        // 而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果
        // 另一个线程执行是需要时间的。
        System.out.println("hello world!");
    }
}

```



## 四、基于线程池的方式

### 1、创建

线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。

```java
// 创建线程池
ExecutorService threadPool = Executors.newFixedThreadPool(10);
while(true) {
    threadPool.execute(new Runnable() { // 提交多个线程任务，并执行
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " is running ..");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
} 
```



### 2、4种线程池

Java 里面线程池的顶级接口是 **Executor**，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 **ExecutorService**

#### a>newCachedThreadPool

创建一个**可根据需要创建新线程的线程池**，但是**在以前构造的线程可用时将重用它们**。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。

`调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。`

因此，长时间保持空闲的线程池不会使用任何资源。

#### b>newFixedThreadPool

创建一个**可重用固定线程数的线程池**，以**共享的无界队列方式来运行**这些线程。

在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

#### c>newScheduledThreadPool

创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

```java
ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3); 
scheduledThreadPool.schedule(newRunnable(){ 
    @Override 
    public void run() {
        System.out.println("延迟三秒");
    }
}, 3, TimeUnit.SECONDS);
scheduledThreadPool.scheduleAtFixedRate(newRunnable(){ 
    @Override 
    public void run() {
        System.out.println("延迟 1 秒后每三秒执行一次");
    }
},1,3,TimeUnit.SECONDS)
```



#### d>newSingleThreadExecutor

Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）

`这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！`

#### e>线程池提交任务的两种方式：execute与submit的区别

<img src = "https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/thread_execute.png" alt="submit" width=600>

<img src = "https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/thread_submit.png" alt="submit" width=600>

- execute只能提交Runnable类型的任务，**无返回值**。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务（会有一个**类型为Future的返回值**），但当任务类型为Runnable时，返回值为null。
- execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。

# 线程生命周期

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/threadLifeCycle202203211430.png" alt="threadLifeCycle">

## 一、新建状态（NEW）

## 二、就绪状态（RUNNABLE）

### start和run的区别

- start()方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码
- 通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行
- `方法 run()称为线程体`，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行 run 函数当中的代码。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。

## 三、运行状态（RUNNING）

## 四、阻塞状态（BLOCKED）

### 1、等待阻塞（o.wait->等待对列）

运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。

### 2、同步阻塞(lock->锁池)

运行(running)的线程在获取对象的同步锁时，若该`同步锁被别的线程占用`，则 JVM 会把该线程放入锁池(lock pool)中。

### 3、其他阻塞(sleep/join)

运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态

## 五、线程死亡

**正常结束**

run() 或 call()方法执行完成，线程正常结束。

**异常结束**

线程抛出一个未捕获的 Exception 或 Error。

**调用stop**

直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用

# 终止线程的4种方式

## 一、正常运行结束

## 二、使用退出标志退出

有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程

```java
public class ThreadSafe extends Thread {
    public volatile boolean exit = false; 
    public void run() { 
        while (!exit){
            //do something
        }
    } 
}
```



## 三、Interrupt方法结束线程

### 1、线程处于阻塞状态

如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。

当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。

通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的，`一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法`。[参考](https://blog.csdn.net/duo_shine/article/details/82423024)

### 2、线程未处于阻塞状态

使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理

```java
public class ThreadSafe extends Thread {
    public void run() { 
        while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出
            try{
                Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出
            }catch(InterruptedException e){
                e.printStackTrace();
                break;//捕获到异常之后，执行 break 跳出循环
            }
        }
    } 
}
```

> Interrupt 后必须在catch里面break才会结束线程，否则只会中断睡眠，抛出异常后还会继续执行
>
> eg. while外还有其他代码时

## 四、stop方法结束线程（线程不安全）

stop调用后会释放所有的锁（不可控制），数据可能会出现不一致

# 后台线程

**守护线程**--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。

守护线程时JVM级别的

在线程启动之前，使用线程对象的`setDaemon(true)`设置为守护线程

GC就是一个经典的守护线程

生命周期与系统一致

# 线程的基本方法

普通java对象的方法：wait，notify，notifyAll，

静态方法：sleep，

线程对象的方法：join，yield

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204120900092.png" alt="image-20220412090046044" style="zoom:67%;" />

## 一、线程等待wait

进入阻塞状态（WAITING状态），直至被唤醒

调用 o.wait()方法后，`会释放对象的锁`。

因此，wait 方法一般用在同步方法或同步代码块中

wait不是线程对象的方法，而是普通java对象的方法

## 二、线程睡眠sleep

sleep 导致当前线程休眠，与 wait 方法不同的是

 `sleep 不会释放当前占有的锁`，

sleep(long)会导致线程进入 TIMED-WATING 状态，

而 wait()方法会导致当前线程进入 WATING 状态

```java
public class ThreadTest07 {
    public static void main(String[] args) {
        //创建线程对象
        Thread t = new MyThread3(); //多态
        //MyThread3 t = new MyThread3();
        t.setName("t");
        t.start();

        // 调用sleep方法
        try {
            // 问：会让线程t进入休眠状态么；不会
            t.sleep(1000*5);
            // sleep是静态方法，和t线程无关，
            // 调用的时候还是会转换成Thread.sleep();
            // 睡眠的是当前线程
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("hello world");
    }
}
```

## wait和sleep的区别

- sleep属于Thread类（静态方法），wait属于Object类
- sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持，当指定的时间到了又会自动恢复运行状态。
- sleep不会释放对象锁；
- wait会释放对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。



## 三、线程让步yield

yield 会使当前线程`让出 CPU 执行时间片`，与其他线程一起`重新竞争` CPU 时间片。

一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。

**Thread的静态方法**

## 四、线程中断interrupt

> 给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。

- 调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。

- 若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态
- 中断状态是线程固有的一个标识位，可以通过其来终止线程；t.interrupt()，然后run方法内根据t.isInterrupted()的值来终止线程

## 五、线程合并join

join() 方法，等待其他线程终止，在当前线程中`调用一个线程的 join() 方法`，则当前线程转为阻塞状态，等到另一个线程结束，当前线程再由阻塞状态变为就绪状态

在a中调用b.join()，a进入阻塞状态，b线程结束后，a线程就绪

#### 使用join的情况

很多情况下，主线程生成并启动了子线程，`需要用到子线程返回的结果`，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。

## 六、线程唤醒notify

Object 类中的 notify() 方法，`唤醒在此对象监视器上等待的单个线程`，如果所有线程都在此对象上等待，则会随机选择唤醒其中一个线程，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，`直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程`，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒此监视器上等待的所有线程

o.notify()让正在o对象上等待的线程唤醒，只是通知，不会释放o对象上之前占有的锁。

> wait和notify方法不是线程对象的方法，是普通java对象都有的方法。

#### 利用wait和notify实现生产者消费者模式

```java
/*
模拟这样一个需求：
   仓库我们采用List集合。
   List集合中假设只能存储1个元素。
   1个元素就表示仓库满了。
   如果List集合中元素个数是0，就表示仓库空了。
   保证List集合中永远都是最多存储1个元素。
   必须做到这种效果：生产1个消费1个。
*/
public class ThreadTest16 {
    public static void main(String[] args) {
        // 创建1个仓库对象，共享的。
        List list = new ArrayList();
        // 创建两个线程对象
        // 生产者线程
        Thread t1 = new Thread(new Producer(list));
        // 消费者线程
        Thread t2 = new Thread(new Consumer(list));

        t1.setName("生产者线程");
        t2.setName("消费者线程");

        t1.start();
        t2.start();
    }
}

// 生产线程
class Producer implements Runnable {
    // 仓库
    private List list;

    public Producer(List list) {
        this.list = list;
    }
    @Override
    public void run() {
        // 一直生产（使用死循环来模拟一直生产）
        while(true){
            // 给仓库对象list加锁。
            synchronized (list){
                if(list.size() > 0){ // 大于0，说明仓库中已经有1个元素了。
                    try {
                        // 当前线程进入等待状态，并且释放Producer之前占有的list集合的锁。
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 程序能够执行到这里说明仓库是空的，可以生产
                Object obj = new Object();
                list.add(obj);
                System.out.println(Thread.currentThread().getName() + "--->" + obj);
                // 唤醒消费者进行消费
                list.notifyAll();
            }
        }
    }
}

// 消费线程
class Consumer implements Runnable {
    // 仓库
    private List list;

    public Consumer(List list) {
        this.list = list;
    }

    @Override
    public void run() {
        // 一直消费
        while(true){
            synchronized (list) {
                if(list.size() == 0){
                    try {
                        // 仓库已经空了。
                        // 消费者线程等待，释放掉list集合的锁
                        list.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                // 程序能够执行到此处说明仓库中有数据，进行消费。
                Object obj = list.remove(0);
                System.out.println(Thread.currentThread().getName() + "--->" + obj);
                // 唤醒生产者生产。
                list.notifyAll();
            }
        }
    }
}
```



## 补充：定时器

```java
// 指定定时任务
//timer.schedule(定时任务, 第一次执行时间, 间隔多久执行一次);
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date firstTime = sdf.parse("2020-03-14 09:34:30");
//timer.schedule(new LogTimerTask() , firstTime, 1000 * 10);
// 每年执行一次。
//timer.schedule(new LogTimerTask() , firstTime, 1000 * 60 * 60 * 24 * 365);

//匿名内部类方式
timer.schedule(new TimerTask(){
    @Override
    public void run() {
        // code....
    }
} , firstTime, 1000 * 10);
```



# 线程上下文切换

巧妙地利用了`时间片轮转的方式`，CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。

时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204121127872.png" alt="image-20220412112730609" style="zoom:67%;" />

#### 上下文

是指某一时间点` CPU 寄存器和程序计数器的内容`

#### PCB切换桢

上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。

#### 上下文切换的活动

1. **挂起**一个进程，将这个进程在 CPU 中的状态（上下文）**存储**于内存中的某处。

2. 在内存中**检索**下一个进程的上下文并将其在 CPU 的寄存器中**恢复**。

3. **跳转**到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。

#### 引起上下文切换的原因

1. 当前执行任务的**时间片**用完之后，系统 CPU 正常调度下一个任务；

2. 当前执行任务碰到 **IO 阻塞**，调度器将此任务挂起，继续下一任务；

3. 多个任务抢占锁资源，当前任务**没有抢到锁资源**，被调度器挂起，继续下一任务；

4. **用户代码挂起当前任务**，让出 CPU 时间；

5. 硬件中断；



# 线程池的原理

线程池做的工作主要是控制运行的线程的数量，处理过程中**将任务放入队列**，然后在线程创建后启动这些任务，如果线程数量超过了最大数量**超出数量的线程排队等候**，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：**线程复用**；**控制最大并发数**；**管理线程**。

## 一、线程复用

每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。

`可以继承重写Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象`。 这就是线程池的实现原理。`循环方法中不断获取 Runnable 是用 Queue 实现的`，在获取下一个 Runnable 之前可以是阻塞的

## 二、组成

1. **线程池管理器**：用于创建并管理线程池

2. **工作线程**：线程池中的线程

3. **任务接口**：每个任务必须实现的接口，用于工作线程调度其运行

4. **任务队列**：用于存放待处理的任务，提供一种缓冲机制

由Executor框架实现

ThreadPoolExecutor 的构造方法如下：

```java
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, 
                          long keepAliveTime,TimeUnit unit, 
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}
```

1. corePoolSize：指定了`线程池中的线程数量`。

2. maximumPoolSize：指定了线程池中的`最大线程数量`。

3. keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多少时间内会被销毁。

4. unit：keepAliveTime 的单位。

5. workQueue：`任务队列`，被提交但尚未被执行的任务。

6. threadFactory：线程工厂，用于创建线程，一般用默认的即可。

7. handler：`拒绝策略`，当任务太多来不及处理，如何拒绝任务。

## 三、拒绝策略

线程已经用完，并且等待队列也已经排满，无法处理新的任务，需要拒绝策略处理这个问题。

1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。

2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接`在调用者线程中`，`运行当前被丢弃的任务`。不会真的丢弃任务，但任务提交线程的性能可能会下降。

3. DiscardOldestPolicy ： `丢弃最老的一个请求`，也就是`即将被执行的一个任务`，并尝试再次提交当前任务。

4. DiscardPolicy ： `丢弃无法处理的任务`。

满足不了要求的情况下可以自行扩展RejectedExecutionHandler接口

## 四、工作过程

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204121423235.png" alt="2FD4CDF1CA1D56EC8AA5ACA7D9215C64" style="zoom: 67%;" />

1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。

2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断：

	a) 如果正在运行的`线程数量小于 corePoolSize`，那么马上`创建线程运行`这个任务；

	b) 如果正在运行的`线程数量大于或等于 corePoolSize`，那么将这个任务`放入队列`；

	c) 如果这时候`队列满了`，而且正在运行的`线程数量小于 maximumPoolSize`，那么还是要`创建非核心线程立刻运行`这个任务；

	d) 如果`队列满了`，而且正在运行的`线程数量大于或等于 maximumPoolSize`，那么线程池会抛出异常 `RejectExecutionException`。

3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。

4. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。

# Java中的阻塞队列

1. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。

	公平、非公（默认）

2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。

	对生产者端和消费者端分别采用了独立的锁，高并发时可以并行地操作队列中的数据

	两个锁提高并发

3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。

	默认自然顺序升序

4. DelayQueue：使用优先级队列实现的无界阻塞队列。

	缓存失效、定时任务

5. SynchronousQueue：不存储元素的阻塞队列。

	每一个put必须等待一个take，类似传球手，吞吐量高

6. LinkedTransferQueue：由链表结构组成的无界阻塞队列。

7. LinkedBlockingDeque：由链表结构组成的双向阻塞队列

# CyclicBarrier和CountDownLatch

## 一、CountDownLatch（线程计数器）

CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch来实现这种功能了

```java
final CountDownLatch latch = new CountDownLatch(2);
new Thread(){public void run() {
    System.out.println("子线程"+Thread.currentThread().getName()+"正在执行");
    Thread.sleep(3000);
    System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕");
    latch.countDown();
};}.start();
new Thread(){ public void run() {
    System.out.println("子线程"+Thread.currentThread().getName()+"正在执行");
    Thread.sleep(3000);
    System.out.println("子线程"+Thread.currentThread().getName()+"执行完毕");
    latch.countDown();
};}.start();
System.out.println("等待 2 个子线程执行完毕...");
latch.await();
System.out.println("2 个子线程已经执行完毕");
System.out.println("继续执行主线程");
```

## 二、CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）

让一组线程`等待至某个状态之后再全部同时执行`。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier `可以被重用`。把这个状态就叫做barrier，当调用`await()`方法之后，线程就处于 barrier 了

CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：

1. public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务；

2. public int await(long timeout, TimeUnit unit)：让这些线程等待一段时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。

```java
public static void main(String[] args) {
    int N = 4;
    CyclicBarrier barrier = new CyclicBarrier(N);
    for(int i=0;i<N;i++)
        new Writer(barrier).start();
}
static class Writer extends Thread{
    private CyclicBarrier cyclicBarrier;
    public Writer(CyclicBarrier cyclicBarrier) {
        this.cyclicBarrier = cyclicBarrier;
    }
    @Override
    public void run() {
        try {
            Thread.sleep(5000); //以睡眠来模拟线程需要预定写入数据操作
            System.out.println("线程"+Thread.currentThread().getName()+"写入数据完毕，等待其他线程写入完毕");
            cyclicBarrier.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }catch(BrokenBarrierException e){
            e.printStackTrace();
        }
        System.out.println("所有线程写入完毕，继续处理其他任务，比如数据操作");
    }
}
```

> CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，侧重点不同；
>
> - CountDownLatch 一般用于某个`线程 A 等待若干个其他线程`执行完任务之后，它才执行；
>
> - CyclicBarrier 一般用于一组线程`互相等待至某个状态`，然后这一组线程再同时执行；
>
> CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。



# volatile（变量可见性、禁止重排序）

在访问 volatile 变量时`不会执行加锁操作`，因此也就不会使执行线程阻塞，

因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。

volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。

值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。

**使用的条件**

- 对变量的写操作不依赖于当前值（i++），或单纯的变量赋值
- 不同的volatile变量之间不能相互依赖



# 线程间如何共享数据

- 将数据抽象成一个类，并将数据的操作作为这个类的方法，在方法上加上synchronized

- Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，

	每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。

# ThreadLocal的作用（线程本地存储）

使用场景：用来解决数据库连接、Session管理等

```java
private static final ThreadLocal threadSession = new ThreadLocal(); 
public static Session getSession() throws InfrastructureException { 
    Session s = (Session) threadSession.get(); 
    try { 
        if (s == null) { 
            s = getSessionFactory().openSession(); 
            threadSession.set(s); 
        } 
    } catch (HibernateException ex) { 
        throw new InfrastructureException(ex); 
    } 
    return s; 
}
```

# Java中的线程调度

## 一、抢占式调度

抢占式调度指的是每条线程`执行的时间`、线程的切换都由`系统控制`。

系统控制指的是在系统某种运行机制下，`时间片长度不固定`，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。

在这种机制下，`一个线程的堵塞不会导致整个进程堵塞`

## 二、协同式调度

协同式调度指某一线程`执行完后主动通知系统切换到另一线程上执行`.

这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。

线程的`执行时间由线程本身控制`，线程切换可以预知，`不存在多线程同步问题`。

**缺点**：如果一个线程编写有问题，运行到一半就一直`堵塞`，那么`可能导致整个系统崩溃`。

## 三、JVM的线程调度实现（抢占式）

按照优先级分配时间片，但也不是绝对，只是优先级高的更可能得到更多的时间片

## 四、线程让出CPU的情况

1. 当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作，例如调用` yield()`方法。

2. 当前运行线程因为某些原因进入阻塞状态，例如`阻塞在 I/O `上。

3. 当前运行线程结束，即`运行完 run()方法`。



# 进程调度算法

## 一、优先调度算法

1. 先来先服务调度算法（FCFS）
2. 短作业（进程）优先调度算法

## 二、高优先权优先调度算法

紧迫型作业优先处理，优先分配给就绪队列中优先权最高的进程

### 1、非抢占式优先权算法

一旦分配给当前队列中优先权最高的进程后，就会一直执行下去

主要用于批处理系统、也可用于实时性要求不严的实时系统

### 2、抢占式优先权算法

分配给当前队列中优先权最高的进程，但是若队列中进来一个优先权更高的，则会重新分配给新的更高优先权的

用于严格的实时系统、以及对性能要求高的批处理系统和分时系统

### 3、高响应比优先调度算法

`Rp = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间`

- 若等待时间相同，要求服务时间越短，其优先权越高，有利于短作业
- 若要求服务时间相同，等待时间越长，其优先权越高，有利于先来先服务

## 三、基于时间片的轮转调度算法

### 1、时间片轮转法

当执行的`时间片用完`时，停止该进程的执行，并将它送往`就绪队列的末尾`；

然后，`再`把处理机分配给就绪队列中新的`队首进程`，同时也让它执行一个时间片。

这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。

### 2、多级反馈队列调度算法

- 设置多个就绪队列，赋予不同的优先级
- 第一个队列的优先级最高，依次降低；`优先级越高`的队列，为每个进程的`时间片越小`
- 当一个进程进入内存后，首先放入第一队列的末尾，排队执行，如果能用第一队列的时间片执行完就撤出系统；`执行不完`则转入第二队列，`依次降入`后面的队列；
- 若降入`第n队列`后，则采用`时间片轮转`的方式
- 仅当第一队列空闲时，才会调用第二队列，依次；
- 若执行第 i 队列的进程时，有进程进入高优先级的队列时，会停止当前进程，将其放入 i 的队尾，先去执行那个高优先级队列的进程

<br>

---



# 锁

局部变量+常量：不会有线程安全问题。（常量dinal不可修改，局部变量不共享）

成员变量：可能会有线程安全问题。

> 执行代码的时候，发现上锁了，才会去寻找锁住的对象是否被其他线程占用。

## 一、18把锁

[18把锁](./Java中的18把锁.md)

## 二、常用概念

### 1、Synchronized（独占、悲观、可重入、非公平）

#### 写法

##### 第一种：同步代码块

灵活

```java
synchronized(线程共享对象){
    同步代码块;
}
```

##### 第二种：在实例方法上使用synchronized

表示共享对象一定是this，并且同步代码块是整个方法体。

如果共享的对象就是this，并且需要同步的代码块是整个方法体，再使用这种方式。

##### 第三种：在静态方法上使用synchronized

表示找类锁。

类锁永远只有1把。

就算创建了100个对象，那类锁也只有一把。

#### a>作用范围***

1. 作用于**实例方法**时，**锁住的是对象的实例(this)**

2. 当作用于**静态方法**时，锁住的是Class实例，又因为Class的相关数据存储在永久带/元空间，是全局共享的。

	因此静态方法锁相当于类的一个全局锁，**会锁所有调用该方法的线程**；

	**不管有多少个对象，类锁只有一个**

3. synchronized 作用于一个**对象实例**时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。

#### b>核心组件

1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；

2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；

3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；

4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；

5) Owner：当前已经获取到所资源的线程被称为 Owner；

6) !Owner：当前释放锁的线程。

#### c>实现

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204111103092.png" alt="43277BF3DD64F9F92F0B76E0042635BD" style="zoom:67%;" />

1. JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。

2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。

3. `Owner 线程并不直接把锁传递给 OnDeck 线程`，而是把**锁竞争的权利**交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“**竞争切换**”。

4. OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。

5. `处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态`，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。

6. Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源
7. 每个对象都有个 monitor 对象，`加锁就是在竞争 monitor 对象`，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的

### 2、ReentrantLock

`ReentantLock 继承接口 Lock `并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如`可响应中断锁、可轮询锁请求、定时锁`等**避免多线程死锁**的方法。

#### a>Lock接口的主要方法

- **void lock()**

	执行此方法时如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.

- **boolean tryLock()**

	如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, **tryLock()只是"尝试"获取锁**, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 **lock()方法则是一定要获取到锁**, 如果锁不可用, 就**一直等待**, 在未获得锁之前,当前线程并不继续向下执行. 

- **void unlock()**

	执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.

- **Condition newCondition()**

	条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await() 方法，而调用后，当前线程将释放锁。

- **tryLock(long timeout TimeUnit unit)**

	如果锁在给定等待时间内没有被另一个线程保持，则获取该锁

> ReentrantLock默认非公平锁，可以初始化为公平锁

```java
public class MyService {
    private Lock lock = new ReentrantLock();
    //Lock lock=new ReentrantLock(true);//公平锁
    //Lock lock=new ReentrantLock(false);//非公平锁
    private Condition condition=lock.newCondition();//创建 Condition
    public void testMethod() {
        try {
            lock.lock();//lock 加锁
            // 1：wait 方法等待：
            // System.out.println("开始 wait");
            condition.await();
            // 通过创建 Condition 对象来使线程 wait，
            // 必须先执行 lock.lock 方法获得锁
            //2：signal 方法唤醒
            condition.signal();
            //condition 对象的 signal 方法可以唤醒 wait 线程
            for (int i = 0; i < 5; i++) {
                System.out.println("ThreadName=" + Thread.currentThread().getName()+ (" " + (i + 1)));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally{
            lock.unlock();
        }
    } 
}
```

#### b>ReentrantLock与Synchronized

> 与 Synchronized 相比，ReentrantLock 的优势是`可中断、公平锁、多个锁`

##### 共同点

- 都用来协调多线程对共享对象、变量的访问
- 都是可重入锁
- 都保证了可见性和互斥性

##### 不同点

- ReentrantLock 通过 lock() 和 unlock() 方法进行加锁解锁，Lock 加锁后需要在finally中`手动解锁`，Synchronized 是`自动解锁`。
- 发生异常时，synchronized会自动释放占有的锁，而lock不会，如果不手动释放，会造成死锁
- ReentrantLock `可响应中断、可轮询`，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性
- ReentrantLock 是` API `级别的，synchronized 是` JVM `级别的

- ReentrantLock 可以实现`公平锁`

- ReentrantLock 通过 Condition 可以`绑定多个条件`

- 底层实现不一样， lock 是`同步非阻塞`，采用的是`乐观并发策略`,synchronized 是`同步阻塞`，使用的是`悲观并发策略`

- Lock 是一个`接口`，而 synchronized 是 Java 中的`关键字`

- Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。

- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 

- Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。

\11. Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。

#### c>Condition类与Object类锁方法区别

1. Condition 类的 awiat 方法和 Object 类的 wait 方法等效

2. Condition 类的 signal 方法和 Object 类的 notify 方法等效

3. Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效

4. ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的

#### d>tryLock、lock、lickInterruptibly的区别

- tryLock非阻塞式
- lock阻塞式
- lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。

### 3、Semaphore

`Semaphore 是一种基于计数的信号量`。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池

**实现互斥锁（计数器为1）**

可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。

```java
// 创建一个计数阈值为 5 的信号量对象
// 只能 5 个线程同时访问
Semaphore semp = new Semaphore(5);
try { // 申请许可
    semp.acquire();
    try {
        // 业务逻辑
    } catch (Exception e) {
    } finally {
        // 释放许可
        semp.release();
    }
} catch (InterruptedException e) {
}
```

**Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似**，通过 **acquire()**与**release()**方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。

此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。

Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。

### 4、AtomicInteger

AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，实现原理相同

## 三、锁的优化策略

**编码过程**中可采取的锁优化的思路

1. **减少锁持有时间**

	对一个方法加锁，不如对方法中需要同步的几行代码加锁。

2. **减少锁粒度**（分段锁）

  缩小锁对象的范围

  ConcurrentHashMap采取对segment加锁而不是整个map加锁，提高并发性。

3. **锁分离**

	根据同步操作的性质，把锁划分为读锁和写锁，ReadWriteLock读写锁。

4. **锁粗化**

	如果一段逻辑中，需要多次加锁解锁，并且加锁解锁的时候没有其他线程来竞争，此时就会把多组加锁操作，合并到一起。

	粗化就是把 **多组加锁解锁**操作合并成一组。每次加锁解锁操作，都有开销，减少加锁的次数，就能提高效率了。

5. **锁消除**

	编译器 + JVM 会根据代码运行的情况智能判定当前的锁是否必要，如果不必要，就直接把加锁的代码忽略。

**Java虚拟机**中采取的锁优化策略
偏向锁、轻量级锁、自旋锁（自适应自旋）




## 四、死锁

### 1、什么是死锁？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。如下图所示：

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051739212.png" alt="222" />

```java
public class DeadLock {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
        //t1和t2共用同一个o1,o2
        Thread t1 = new MyThread1(o1,o2);
        Thread t2 = new MyThread1(o1,o2);
    }
}

class MyThread1 extends Thread{
    Object o1;
    Object o2;
    public MyThread1(Object o1, Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o1){//睡一下必定出问题，死锁
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2){

            }
        }
    }
}

class MyThread2 extends Thread{
    Object o1;
    Object o2;
    public MyThread2(Object o1, Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o2){//睡一下必定出问题，死锁
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){

            }
        }
    }
}
```



### 2、产生死锁的原因？

1. **竞争资源**
	- 系统中的资源可以分为两类：
		- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
		- 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
	- 产生死锁中的竞争资源之一指的是**竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
	- 产生死锁中的竞争资源另外一种资源指的是**竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
2. **进程间推进顺序非法**
	- 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
	- 例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



### 3、产生死锁的必要条件

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。



### 4、解决死锁的基本方法

预防，避免，检测，解除

#### a>预防死锁

> - 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
> - 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
> - 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
> - 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

1. **以确定的顺序获得锁**

	如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。按照上面的例子，两个线程获得锁的时序图如下：

	<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051740961.png" alt="2443" style="zoom:80%;" />

	如果此时把获得锁的时序改成：

	<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051741491.png" alt="22333" style="zoom:80%;" />

	那么死锁就永远不会发生。 针对两个特定的锁，开发者可以尝试按照锁对象的hashCode值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的hashCode进行排序（单纯按照hashCode顺序排序会出现“环路等待”），可能就无法满足要求了，这个时候开发者可以使用银行家算法，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生。
	
2. **超时放弃**

	当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 



#### b>避免死锁

- 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。

- **系统在进行资源分配之前预先计算资源分配的安全性**。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。

- **银行家算法**：

	> 1、申请的贷款额度不能超过银行现有的资金总额
	> 2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额
	> 3、暂时不能满足客户申请的资金额度时，在有限时间内给予贷款
	> 4、客户要在规定的时间内还款

	- 首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。
		

#### c>检测死锁

[资源分配图](https://blog.csdn.net/jgm20475/article/details/81297819)

首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表。

- Jstack命令

	jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

- JConsole工具

	Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。



#### d>解除死锁

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

- **剥夺资源**：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
- **撤消进程**：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
- **进程回退**：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。



# 集合线程安全问题

## 一、List

```java
// 具体集合类型ArrayList：
// 抛出java.util.ConcurrentModificationException异常

// 具体集合类型Vector：
// 不会抛异常，线程安全，但是这个类太古老

Collections.synchronizedList(new ArrayList<>())：
// 不会抛异常，但是锁定范围大，性能低
public void add(int index, E element) { 
    synchronized (mutex) {
        list.add(index, element);
    } 
}
public E get(int index) { 
    synchronized (mutex) {
        return list.get(index);
    } 
}

// 具体集合类型CopyOnWriteArrayList：
// 使用了写时复制技术，兼顾了线程安全和并发性能
List<String> list = new CopyOnWriteArrayList<>();
```

### 写时复制技术

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072009224.png" alt="image-20220407200925958" style="zoom:80%;" />

- 使用写时复制技术要向集合对象中写入数据时：先把整个集合数组复制一份
- 将新数据写入复制得到的新集合数组
- 再让指向集合数组的变量指向新复制的集合数组

优缺点：

- 优点：兼顾了性能和线程安全，允许同时进行读写操作
- 缺点：由于需要把集合对象整体复制一份，所以对内存的消耗很大

对应类中的源代码：

- 所在类：java.util.concurrent.CopyOnWriteArrayList

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```



## 二、Set

采用了写时复制技术的Set集合：java.util.concurrent.CopyOnWriteArraySet

```java
// 测试
// 1、创建集合对象
Set<String> set = new CopyOnWriteArraySet<>();
// 2、创建多个线程，每个线程中读写 List 集合
for (int i = 0; i < 5; i++) {
    new Thread(()->{
        for (int j = 0; j < 5; j++) {
            // 写操作：随机生成字符串存入集合
            set.add(UUID.randomUUID().toString().
                    replace("-","").substring(0, 5));
            // 读操作：打印集合整体
            System.out.println("set = " + set);
        }
    }, "thread-"+i).start();
}
```

源码

- 所在类：java.util.concurrent.CopyOnWriteArraySet

```java
public boolean add(E e) {
    return al.addIfAbsent(e);
}
```

- 所在类：java.util.concurrent.CopyOnWriteArrayList

```java
private boolean addIfAbsent(E e, Object[] snapshot) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] current = getArray();
        int len = current.length;
        if (snapshot != current) {
            // Optimize for lost race to another addXXX operation
            int common = Math.min(snapshot.length, len);
            for (int i = 0; i < common; i++)
                if (current[i] != snapshot[i] && eq(e, current[i]))
                    return false;
            if (indexOf(e, current, common, len) >= 0)
                return false;
        }
        Object[] newElements = Arrays.copyOf(current, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```



## 三、Map

```java
java.util.concurrent.ConcurrentHashMap
```

```java
// 1、创建集合对象
Map<String, String> map = new ConcurrentHashMap<>();
// 2、创建多个线程执行读写操作
for (int i = 0; i < 5; i++) {
    new Thread(()->{
        for (int j = 0; j < 5; j++) {
            String key = UUID.randomUUID().toString().replace("-","").substring(0, 5);
            String value = UUID.randomUUID().toString().replace("-","").substring(0, 5);
            map.put(key, value);
            System.out.println("map = " + map);
        }
    }, "thread" + i).start();
}
```

#### a>Segment段

ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为`段(Segment)`。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。

如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该表项应该存放在哪个段中，然后`对该段加锁`，并完成 put 操作。

在多线程环境中，如果多个线程同时进行 put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。

#### b>线程安全（Segment 继承 ReentrantLock 加锁）

简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作**锁住的是一个 segment**，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061546572.png" alt="image-20220406154643937" style="zoom:80%;" />

每个segment也具有红黑树结构

ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。

Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。

每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。

#### c>并行度（默认16）

concurrencyLevel：并行级别、并发数、Segment 数。

也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。

`可以初始化赋值，但是初始化后不可扩容`

每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。
