





# CAS（比较并交换-乐观锁机制-锁自旋）

## 一、概念

CAS（Compare-And-Swap）是`比较并交换`的意思，它是一条 CPU 并发原语，用于判断内存中某个值是否为预期值，如果是则更改为新的值，这个过程是`原子`的。

> **可以保证原子吗？可以**
>
> CAS 是一种`系统原语`，原语属于操作系统用语，原语由若干指令组成，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说 CAS 是一条 CPU 的原子指令，由操作系统硬件来保证。

CAS机制当中使用了3个基本操作数：

- 内存地址V
- 旧的预期值E
- 计算后要修改后的新值N

当且仅当 V 值于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。

```java
return V = V == E ? N : V;
```

## 二、CAS在Java中的应用

**原子包 java.util.concurrent.atomic（锁自旋）**

这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，<strong style="color:#03468F">即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入</strong>，这只是一种逻辑上的理解。

相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。由于一般 CPU 切换时间比 CPU 指令集操作更加长， 所以 J.U.C 在性能上有了很大的提升。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072036985.png" style="zoom: 67%;" />

比如说 AtomicInteger 类就可以解决 i++ 非原子性问题，通过查看源码可以发现主要是靠 volatile 关键字和 CAS 操作来实现。

```java
public class AtomicInteger extends Number implements java.io.Serializable { 
	private volatile int value; 
	public final int get() {  
        return value; 
 	} 
	public final int getAndIncrement() { 
    	for (;;) { //CAS 自旋，一直尝试，直达成功
            int current = get(); 
            int next = current + 1; 
            if (compareAndSet(current, next)) 
                return current; 
        } 
 	} 
 	public final boolean compareAndSet(int expect, int update) { 
 		// JNI
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update); 
 	} 
}
```

## 三、CAS的问题***

### 1、 典型 ABA 问题

ABA 是 CAS 操作的一个经典问题，假设有一个变量初始值为 A，修改为 B，然后又修改为 A，这个变量实际被修改过了，但是 CAS 操作可能无法感知到。

如果是整形还好，不会影响最终结果，但如果是对象的引用类型包含了多个变量，引用没有变实际上包含的变量已经被修改，这就会造成大问题。

解决方法：在变量前加版本号，每次变量更新了就把版本号加一，结果如下：

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072041052.png" style="zoom: 33%;" />

最终结果都是 A 但是版本号改变了。

从 JDK 1.5 开始提供了`AtomicStampedReference`类，这个类的 `compareAndSe `方法首先检查`当前引用`是否等于`预期引用`，并且`当前标志`是否等于`预期标志`，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

### 2、自旋开销问题

CAS 出现冲突后就会开始`自旋`操作，如果资源竞争非常激烈，自旋长时间不能成功就会给 CPU 带来非常大的开销。

解决方案：可以考虑限制自旋的次数，避免过度消耗 CPU；另外还可以考虑延迟执行。

### 3、只能保证单个变量的原子性

当对一个共享变量执行操作时，可以使用 CAS 来保证原子性，但是如果要对多个共享变量进行操作时，CAS 是无法保证原子性的，比如需要将 i 和 j 同时加 1：

```java
i++;
j++;
```

这个时候可以使用 synchronized 进行加锁，有没有其他办法呢？有，将多个变量操作合成一个变量操作。从 JDK1.5 开始提供了`AtomicReference` 类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

<br>

# AQS（抽象的队列同步器）

AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的

ReentrantLock、Semaphore、CountDownLatch

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072047099.png" alt="image-20220407204738166" style="zoom:80%;" />

它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词。state 的访问方式有三种：

- getState()
- setState()
- compareAndSetState()

AQS定义两种资源共享方式：

- Exclusive（独占，只有一个线程能执行，如 ReentrantLock）
- Share（共享，多个线程可同时执行，如 Semaphore、CountDownLatch ）。

`AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现`，AQS 这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS）。

之所以没有定义成abstract ，是因为**独占模式**下只用实现 tryAcquire-tryRelease ，而**共享模式**下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。

自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：

1．isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。

2．tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 

3．tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 

4．tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。

5．tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072055382.png" alt="image-20220407205526565" style="zoom:67%;" />

<br>

# 线程的实现与创建方式

## 一、继承Thread类

Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的start()实例方法。`start()方法是一个 native 方法`，它将启动一个新线程，并执行run()方法。

```java
public class ThreadTest02 {
    public static void main(String[] args) {
        // 这里是main方法，这里的代码属于主线程，在主栈中运行。
        // 新建一个分支线程对象
        MyThread t = new MyThread();
        // 启动线程
        // t.run(); // 不会启动线程，不会分配新的分支栈。（这种方式就是单线程。）
        // start()方法的作用是：启动一个分支线程，在JVM中开辟一个新的栈空间，
        // 这段代码任务完成之后，瞬间就结束了。
        // 其任务只是为了开启一个新的栈空间，
        // 只要新的栈空间开出来，start()方法就结束了。线程就启动成功了。
        // 启动成功的线程会自动调用run方法，并且run方法在分支栈的栈底部（压栈）。
        // run方法在分支栈的栈底部，main方法在主栈的栈底部。run和main是平级的。
        t.start();
        // 这里的代码还是运行在主线程中。
        for(int i = 0; i < 1000; i++){
            System.out.println("主线程--->" + i);
        }
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        // 编写程序，这段程序运行在分支线程中（分支栈）。
        for(int i = 0; i < 1000; i++){
            System.out.println("分支线程--->" + i);
        }
    }
}
```



## 二、实现Runnable接口

如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口。

```java
public class ThreadTest03 {
    public static void main(String[] args) {
        //创建一个可运行的对象
        //MyRunnable r = new MyRunnable();
        //将可运行的对象封装成一个线程对象
        Thread t = new Thread(new MyRunnable());
        //启动线程
        t.start();
        for(int i = 0; i < 100; i++){
            System.out.println("主线程--->" + i);
        }
    }
}

//这并不是一个线程类，是一个可运行的类，还不是一个线程
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 100; i++){
            System.out.println("分支线程--->" + i);
        }
    }
}
```



## 三、ExecutorService、Callable\<Class>、Future有返回值线程

`有返回值的任务必须实现 Callable 接口`，类似的，`无返回值的任务必须 Runnable 接口`。执行Callable 任务后，`可以获取一个 Future 的对象`，在该对象上`调用 get `就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。

这种方式的缺点：效率比较低，在获取 t 线程执行结果的时候，当前线程受阻塞，效率较低。

```java
//创建一个线程池
ExecutorService pool = Executors.newFixedThreadPool(taskSize);
// 创建多个有返回值的任务
List<Future> list = new ArrayList<Future>(); 
for (int i = 0; i < taskSize; i++) { 
    Callable c = new MyCallable(i + " "); 
    // 执行任务并获取 Future 对象
    Future f = pool.submit(c); 
    list.add(f); 
} 
// 关闭线程池
pool.shutdown(); 
// 获取所有并发任务的运行结果
for (Future f : list) { 
	// 从 Future 对象上获取任务的返回值，并输出到控制台
	System.out.println("res：" + f.get().toString()); 
}
```



```java
import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class ThreadTest15 {
    public static void main(String[] args) throws Exception {
        // 第一步：创建一个"未来任务类"对象
        FutureTask task = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception { 
                //call()就相当于run()只不过有返回值
                return Obj;
        });
        // 创建线程对象
        Thread t = new Thread(task);
        // 启动线程
        t.start();
        // 这里是main方法，这是在主线程中。
        // 在主线程中，怎么获取t线程的返回结果？
        // get()方法的执行会导致“当前线程阻塞”
        Object obj = task.get();
        System.out.println("线程执行结果:" + obj);
        // main方法这里的程序要想执行必须等待get()方法的结束
        // 而get()方法可能需要很久。因为get()方法是为了拿另一个线程的执行结果
        // 另一个线程执行是需要时间的。
        System.out.println("hello world!");
    }
}

```



## 四、基于线程池的方式

### 1、创建

线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。

```java
// 创建线程池
ExecutorService threadPool = Executors.newFixedThreadPool(10);
while(true) {
    threadPool.execute(new Runnable() { // 提交多个线程任务，并执行
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + " is running ..");
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });
} 
```



### 2、4种线程池

Java 里面线程池的顶级接口是 **Executor**，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 **ExecutorService**

#### a>newCachedThreadPool

创建一个**可根据需要创建新线程的线程池**，但是**在以前构造的线程可用时将重用它们**。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。

`调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。`

因此，长时间保持空闲的线程池不会使用任何资源。

#### b>newFixedThreadPool

创建一个**可重用固定线程数的线程池**，以**共享的无界队列方式来运行**这些线程。

在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。

#### c>newScheduledThreadPool

创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

```java
ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3); 
scheduledThreadPool.schedule(newRunnable(){ 
    @Override 
    public void run() {
        System.out.println("延迟三秒");
    }
}, 3, TimeUnit.SECONDS);
scheduledThreadPool.scheduleAtFixedRate(newRunnable(){ 
    @Override 
    public void run() {
        System.out.println("延迟 1 秒后每三秒执行一次");
    }
},1,3,TimeUnit.SECONDS)
```



#### d>newSingleThreadExecutor

Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）

`这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！`

#### e>线程池提交任务的两种方式：execute与submit的区别

<img src = "https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/thread_execute.png" alt="submit" width=600>

<img src = "https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/thread_submit.png" alt="submit" width=600>

- execute只能提交Runnable类型的任务，**无返回值**。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务（会有一个**类型为Future的返回值**），但当任务类型为Runnable时，返回值为null。
- execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。

# 线程生命周期

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/threadLifeCycle202203211430.png" alt="threadLifeCycle">

## 一、新建状态（NEW）

## 二、就绪状态（RUNNABLE）

## 三、运行状态（RUNNING）

## 四、阻塞状态（BLOCKED）

### 1、等待阻塞（o.wait->等待对列）

运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列(waitting queue)中。

### 2、同步阻塞(lock->锁池)

运行(running)的线程在获取对象的同步锁时，若该`同步锁被别的线程占用`，则 JVM 会把该线程放入锁池(lock pool)中。

### 3、其他阻塞(sleep/join)

运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O处理完毕时，线程重新转入可运行(runnable)状态

## 五、线程死亡

**正常结束**

run() 或 call()方法执行完成，线程正常结束。

**异常结束**

线程抛出一个未捕获的 Exception 或 Error。

**调用stop**

直接调用该线程的 stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用

# 终止线程的4种方式

## 一、正常运行结束

## 二、使用退出标志退出

有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程

```java
public class ThreadSafe extends Thread {
    public volatile boolean exit = false; 
    public void run() { 
        while (!exit){
            //do something
        }
    } 
}
```



## 三、Interrupt方法结束线程

### 1、线程处于阻塞状态

如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。

当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。

通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的，`一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法`。[参考](https://blog.csdn.net/duo_shine/article/details/82423024)

### 2、线程未处于阻塞状态

使用 isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理

```java
public class ThreadSafe extends Thread {
    public void run() { 
        while (!isInterrupted()){ //非阻塞过程中通过判断中断标志来退出
            try{
                Thread.sleep(5*1000);//阻塞过程捕获中断异常来退出
            }catch(InterruptedException e){
                e.printStackTrace();
                break;//捕获到异常之后，执行 break 跳出循环
            }
        }
    } 
}
```

> Interrupt 后必须在catch里面break才会结束线程，否则只会中断睡眠，抛出异常后还会继续执行
>
> eg. while外还有其他代码时

## 四、stop方法结束线程（线程不安全）

stop调用后会释放所有的锁（不可控制），数据可能会出现不一致

# 后台线程

**守护线程**--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。

守护线程时JVM级别的

在线程启动之前，使用线程对象的`setDaemon(true)`设置为守护线程

GC就是一个经典的守护线程

生命周期与系统一致

# 线程的基本方法

wait，notify，notifyAll，sleep，join，yield

# 线程上下文切换



---

<br>

# 锁

## 一、18把锁

[18把锁](./Java中的18把锁.md)

## 二、常用概念

### 1、Synchronized（独占、悲观、可重入、非公平）

#### a>作用范围***

1. 作用于**方法**时，**锁住的是对象的实例(this)**；

2. 当作用于**静态方法**时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，**会锁所有调用该方法的线程**；

3. synchronized 作用于一个**对象实例**时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。

#### b>核心组件

1) Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；

2) Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；

3) Entry List：Contention List 中那些有资格成为候选资源的线程被移动到 Entry List 中；

4) OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck；

5) Owner：当前已经获取到所资源的线程被称为 Owner；

6) !Owner：当前释放锁的线程。

#### c>实现

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204111103092.png" alt="43277BF3DD64F9F92F0B76E0042635BD" style="zoom:67%;" />

1. JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。

2. Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。

3. `Owner 线程并不直接把锁传递给 OnDeck 线程`，而是把**锁竞争的权利**交给 OnDeck，OnDeck 需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“**竞争切换**”。

4. OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList中。如果 Owner 线程被 wait 方法阻塞，则转移到 WaitSet 队列中，直到某个时刻通过 notify或者 notifyAll 唤醒，会重新进去 EntryList 中。

5. `处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态`，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。

6. Synchronized 是非公平锁。 Synchronized 在线程进入 ContentionList 时，等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源
7. 每个对象都有个 monitor 对象，`加锁就是在竞争 monitor 对象`，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的

### 2、ReentrantLock

`ReentantLock 继承接口 Lock `并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如`可响应中断锁、可轮询锁请求、定时锁`等**避免多线程死锁**的方法。

#### a>Lock接口的主要方法

- **void lock()**

	执行此方法时如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.

- **boolean tryLock()**

	如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于, **tryLock()只是"尝试"获取锁**, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 **lock()方法则是一定要获取到锁**, 如果锁不可用, 就**一直等待**, 在未获得锁之前,当前线程并不继续向下执行. 

- **void unlock()**

	执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.

- **Condition newCondition()**

	条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await() 方法，而调用后，当前线程将释放锁。

- **tryLock(long timeout TimeUnit unit)**

	如果锁在给定等待时间内没有被另一个线程保持，则获取该锁

> ReentrantLock默认非公平锁，可以初始化为公平锁

#### b>ReentrantLock与Synchronized

ReentrantLock 通过 lock() 和 unlock() 方法进行加锁解锁，Lock 加锁后需要手动解锁，Synchronized 是自动解锁。

与 Synchronized 相比，ReentrantLock 的优势是`可中断、公平锁、多个锁`

```java
public class MyService {
    private Lock lock = new ReentrantLock();
    //Lock lock=new ReentrantLock(true);//公平锁
    //Lock lock=new ReentrantLock(false);//非公平锁
    private Condition condition=lock.newCondition();//创建 Condition
    public void testMethod() {
        try {
            lock.lock();//lock 加锁
            // 1：wait 方法等待：
            // System.out.println("开始 wait");
            condition.await();
            // 通过创建 Condition 对象来使线程 wait，
            // 必须先执行 lock.lock 方法获得锁
            //2：signal 方法唤醒
            condition.signal();
            //condition 对象的 signal 方法可以唤醒 wait 线程
            for (int i = 0; i < 5; i++) {
                System.out.println("ThreadName=" + Thread.currentThread().getName()+ (" " + (i + 1)));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally{
            lock.unlock();
        }
    } 
}
```



#### c>Condition类与Object类锁方法区别

1. Condition 类的 awiat 方法和 Object 类的 wait 方法等效

2. Condition 类的 signal 方法和 Object 类的 notify 方法等效

3. Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效

4. ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的

#### d>tryLock、lock、lickInterruptibly的区别

- tryLock非阻塞式
- lock阻塞式
- lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock 不会抛出异常，而 lockInterruptibly 会抛出异常。

### 3、Semaphore

`Semaphore 是一种基于计数的信号量`。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池

**实现互斥锁（计数器为1）**

可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。

```java
// 创建一个计数阈值为 5 的信号量对象
// 只能 5 个线程同时访问
Semaphore semp = new Semaphore(5);
try { // 申请许可
    semp.acquire();
    try {
        // 业务逻辑
    } catch (Exception e) {
    } finally {
        // 释放许可
        semp.release();
    }
} catch (InterruptedException e) {
}
```

**Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似**，通过 **acquire()**与**release()**方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。

此外，Semaphore 也实现了可轮询的锁请求与定时锁的功能，除了方法名 tryAcquire 与 tryLock不同，其使用方法与 ReentrantLock 几乎一致。Semaphore 也提供了公平与非公平锁的机制，也可在构造函数中进行设定。

Semaphore 的锁释放操作也由手动进行，因此与 ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。

### 4、AtomicInteger

AtomicInteger ，一个提供原子操作的 Integer 的类，常见的还有 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，实现原理相同

## 三、锁的优化策略

**编码过程**中可采取的锁优化的思路

1. **减少锁持有时间**

	对一个方法加锁，不如对方法中需要同步的几行代码加锁。

2. **减少锁粒度**（分段锁）

	ConcurrentHashMap采取对segment加锁而不是整个map加锁，提高并发性。

3. **锁分离**

	根据同步操作的性质，把锁划分为读锁和写锁，ReadWriteLock读写锁。

4. **锁粗化**

	如果一段逻辑中，需要多次加锁解锁，并且加锁解锁的时候没有其他线程来竞争，此时就会把多组加锁操作，合并到一起。

	粗化就是把 **多组加锁解锁**操作合并成一组。每次加锁解锁操作，都有开销，减少加锁的次数，就能提高效率了。

5. **锁消除**

	编译器 + JVM 会根据代码运行的情况智能判定当前的锁是否必要，如果不必要，就直接把加锁的代码忽略。

**Java虚拟机**中采取的锁优化策略
偏向锁、轻量级锁、自旋锁（自适应自旋）




## 四、死锁

### 1、什么是死锁？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。如下图所示：

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051739212.png" alt="222" />

```java
public class DeadLock {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
        //t1和t2共用同一个o1,o2
        Thread t1 = new MyThread1(o1,o2);
        Thread t2 = new MyThread1(o1,o2);
    }
}

class MyThread1 extends Thread{
    Object o1;
    Object o2;
    public MyThread1(Object o1, Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o1){//睡一下必定出问题，死锁
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2){

            }
        }
    }
}

class MyThread2 extends Thread{
    Object o1;
    Object o2;
    public MyThread2(Object o1, Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o2){//睡一下必定出问题，死锁
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){

            }
        }
    }
}
```



### 2、产生死锁的原因？

1. **竞争资源**
	- 系统中的资源可以分为两类：
		- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
		- 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
	- 产生死锁中的竞争资源之一指的是**竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
	- 产生死锁中的竞争资源另外一种资源指的是**竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
2. **进程间推进顺序非法**
	- 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
	- 例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



### 3、产生死锁的必要条件

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。



### 4、解决死锁的基本方法

预防，避免，检测，解除

#### a>预防死锁

> - 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
> - 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
> - 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
> - 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

1. **以确定的顺序获得锁**

	如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。按照上面的例子，两个线程获得锁的时序图如下：

	<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051740961.png" alt="2443" style="zoom:80%;" />

	如果此时把获得锁的时序改成：

	<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051741491.png" alt="22333" style="zoom:80%;" />

	那么死锁就永远不会发生。 针对两个特定的锁，开发者可以尝试按照锁对象的hashCode值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的hashCode进行排序（单纯按照hashCode顺序排序会出现“环路等待”），可能就无法满足要求了，这个时候开发者可以使用银行家算法，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生。
	
2. **超时放弃**

	当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 



#### b>避免死锁

- 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。

- **系统在进行资源分配之前预先计算资源分配的安全性**。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。

- **银行家算法**：

	> 1、申请的贷款额度不能超过银行现有的资金总额
	> 2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额
	> 3、暂时不能满足客户申请的资金额度时，在有限时间内给予贷款
	> 4、客户要在规定的时间内还款

	- 首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。
		

#### c>检测死锁

[资源分配图](https://blog.csdn.net/jgm20475/article/details/81297819)

首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表。

- Jstack命令

	jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

- JConsole工具

	Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。



#### d>解除死锁

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

- **剥夺资源**：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
- **撤消进程**：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
- **进程回退**：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。



# 集合线程安全问题

## 一、List

```java
// 具体集合类型ArrayList：
// 抛出java.util.ConcurrentModificationException异常

// 具体集合类型Vector：
// 不会抛异常，线程安全，但是这个类太古老

Collections.synchronizedList(new ArrayList<>())：
// 不会抛异常，但是锁定范围大，性能低
public void add(int index, E element) { 
    synchronized (mutex) {
        list.add(index, element);
    } 
}
public E get(int index) { 
    synchronized (mutex) {
        return list.get(index);
    } 
}

// 具体集合类型CopyOnWriteArrayList：
// 使用了写时复制技术，兼顾了线程安全和并发性能
List<String> list = new CopyOnWriteArrayList<>();
```

### 写时复制技术

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204072009224.png" alt="image-20220407200925958" style="zoom:80%;" />

- 使用写时复制技术要向集合对象中写入数据时：先把整个集合数组复制一份
- 将新数据写入复制得到的新集合数组
- 再让指向集合数组的变量指向新复制的集合数组

优缺点：

- 优点：兼顾了性能和线程安全，允许同时进行读写操作
- 缺点：由于需要把集合对象整体复制一份，所以对内存的消耗很大

对应类中的源代码：

- 所在类：java.util.concurrent.CopyOnWriteArrayList

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```



## 二、Set

采用了写时复制技术的Set集合：java.util.concurrent.CopyOnWriteArraySet

```java
// 测试
// 1、创建集合对象
Set<String> set = new CopyOnWriteArraySet<>();
// 2、创建多个线程，每个线程中读写 List 集合
for (int i = 0; i < 5; i++) {
    new Thread(()->{
        for (int j = 0; j < 5; j++) {
            // 写操作：随机生成字符串存入集合
            set.add(UUID.randomUUID().toString().
                    replace("-","").substring(0, 5));
            // 读操作：打印集合整体
            System.out.println("set = " + set);
        }
    }, "thread-"+i).start();
}
```

源码

- 所在类：java.util.concurrent.CopyOnWriteArraySet

```java
public boolean add(E e) {
    return al.addIfAbsent(e);
}
```

- 所在类：java.util.concurrent.CopyOnWriteArrayList

```java
private boolean addIfAbsent(E e, Object[] snapshot) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] current = getArray();
        int len = current.length;
        if (snapshot != current) {
            // Optimize for lost race to another addXXX operation
            int common = Math.min(snapshot.length, len);
            for (int i = 0; i < common; i++)
                if (current[i] != snapshot[i] && eq(e, current[i]))
                    return false;
            if (indexOf(e, current, common, len) >= 0)
                return false;
        }
        Object[] newElements = Arrays.copyOf(current, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```



## 三、Map

```java
java.util.concurrent.ConcurrentHashMap
```

```java
// 1、创建集合对象
Map<String, String> map = new ConcurrentHashMap<>();
// 2、创建多个线程执行读写操作
for (int i = 0; i < 5; i++) {
    new Thread(()->{
        for (int j = 0; j < 5; j++) {
            String key = UUID.randomUUID().toString().replace("-","").substring(0, 5);
            String value = UUID.randomUUID().toString().replace("-","").substring(0, 5);
            map.put(key, value);
            System.out.println("map = " + map);
        }
    }, "thread" + i).start();
}
```

