# 线程生命周期

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/threadLifeCycle202203211430.png" alt="threadLifeCycle">




​	

# interrupt能否停止线程

[参考](https://blog.csdn.net/duo_shine/article/details/82423024)



# 线程池提交任务的两种方式：execute与submit的区别

<img src = "https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/thread_execute.png" alt="submit" width=600>

<img src = "https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/thread_submit.png" alt="submit" width=600>

- execute只能提交Runnable类型的任务，**无返回值**。submit既可以提交Runnable类型的任务，也可以提交Callable类型的任务（会有一个**类型为Future的返回值**），但当任务类型为Runnable时，返回值为null。
- execute在执行任务时，如果遇到异常会直接抛出，而submit不会直接抛出，只有在使用Future的get方法获取返回值时，才会抛出异常。



# 锁

## 一、18把锁

[18把锁](./Java中的18把锁.md)

## 二、锁的优化策略

**编码过程**中可采取的锁优化的思路

1. **减少锁持有时间**

	对一个方法加锁，不如对方法中需要同步的几行代码加锁。

2. **减少锁粒度**（分段锁）

	ConcurrentHashMap采取对segment加锁而不是整个map加锁，提高并发性。

3. **锁分离**

	根据同步操作的性质，把锁划分为读锁和写锁，ReadWriteLock读写锁。

4. **锁粗化**

	如果一段逻辑中，需要多次加锁解锁，并且加锁解锁的时候没有其他线程来竞争，此时就会把多组加锁操作，合并到一起。

	粗化就是把 **多组加锁解锁**操作合并成一组。每次加锁解锁操作，都有开销，减少加锁的次数，就能提高效率了。

5. **锁消除**

	编译器 + JVM 会根据代码运行的情况智能判定当前的锁是否必要，如果不必要，就直接把加锁的代码忽略。

**Java虚拟机**中采取的锁优化策略
偏向锁、轻量级锁、自旋锁（自适应自旋）




## 三、死锁

### 1、什么是死锁？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。 因此我们举个例子来描述，如果此时有一个线程A，按照先锁a再获得锁b的的顺序获得锁，而在此同时又有另外一个线程B，按照先锁b再锁a的顺序获得锁。如下图所示：

<img src="https://img-blog.csdn.net/20180922173936964?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" />

```java
public class DeadLock {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
        //t1和t2共用同一个o1,o2
        Thread t1 = new MyThread1(o1,o2);
        Thread t2 = new MyThread1(o1,o2);
    }
}

class MyThread1 extends Thread{
    Object o1;
    Object o2;
    public MyThread1(Object o1, Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o1){//睡一下必定出问题，死锁
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2){

            }
        }
    }
}

class MyThread2 extends Thread{
    Object o1;
    Object o2;
    public MyThread2(Object o1, Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o2){//睡一下必定出问题，死锁
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){

            }
        }
    }
}
```



### 2、产生死锁的原因？

1. **竞争资源**
	- 系统中的资源可以分为两类：
		- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
		- 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
	- 产生死锁中的竞争资源之一指的是**竞争不可剥夺资源**（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
	- 产生死锁中的竞争资源另外一种资源指的是**竞争临时资源**（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
2. **进程间推进顺序非法**
	- 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
	- 例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



### 3、产生死锁的必要条件

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。



### 4、解决死锁的基本方法

预防，避免，检测，解除

#### 预防死锁

> - 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
> - 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
> - 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
> - 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

1. **以确定的顺序获得锁**

	如果必须获取多个锁，那么在设计的时候需要充分考虑不同线程之前获得锁的顺序。按照上面的例子，两个线程获得锁的时序图如下：

	<img src="https://img-blog.csdn.net/20180922174807514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" />

	如果此时把获得锁的时序改成：

	<img src="https://img-blog.csdn.net/20180922174829303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hkMTIzNzA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"/>

	那么死锁就永远不会发生。 针对两个特定的锁，开发者可以尝试按照锁对象的hashCode值大小的顺序，分别获得两个锁，这样锁总是会以特定的顺序获得锁，那么死锁也不会发生。问题变得更加复杂一些，如果此时有多个线程，都在竞争不同的锁，简单按照锁对象的hashCode进行排序（单纯按照hashCode顺序排序会出现“环路等待”），可能就无法满足要求了，这个时候开发者可以使用银行家算法，所有的锁都按照特定的顺序获取，同样可以防止死锁的发生。
	
2. **超时放弃**

	当使用synchronized关键词提供的内置锁时，只要线程没有获得锁，那么就会永远等待下去，然而Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。通过这种方式，也可以很有效地避免死锁。 



#### 避免死锁

- 预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得 较满意的系统性能。由于在避免死锁的策略中，允许进程动态地申请资源。

- **系统在进行资源分配之前预先计算资源分配的安全性**。若此次分配不会导致系统进入不安全的状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是银行家算法。

- **银行家算法**：

	> 1、申请的贷款额度不能超过银行现有的资金总额
	> 2、分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额
	> 3、暂时不能满足客户申请的资金额度时，在有限时间内给予贷款
	> 4、客户要在规定的时间内还款

	- 首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。
		

#### 检测死锁

[资源分配图](https://blog.csdn.net/jgm20475/article/details/81297819)

首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表。

- Jstack命令

	jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

- JConsole工具

	Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。



#### 解除死锁

当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：

- **剥夺资源**：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
- **撤消进程**：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。
- **进程回退**：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。
