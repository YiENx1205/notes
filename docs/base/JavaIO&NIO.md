# 基础IO模型

## 一、阻塞IO模型

最传统的一种 IO 模型，即`在读写数据过程中会发生阻塞现象`。

当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果`没有就绪就会等待数据就绪`，而用户线程就会处于阻塞状态，用户线程交出 CPU。

当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：

```java
data = socket.read();
```

如果数据没有就绪，就会一直阻塞在 read 方法。

## 二、非阻塞IO模型

当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

所以事实上，在非阻塞 IO 模型中，用户线程需要`不断地询问内核数据是否就绪`，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：

```java
while(true){
    data = socket.read();
    if(data!= error){
        // 处理数据
        break;
    }
}
```

但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会**导致 CPU 占用率非常高**，因此一般情况下很少使用 while 循环这种方式来读取数据

## 三、多路复用IO模型

多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO 模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个

socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有

socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通

过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这

种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当

socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连

接数比较多的情况。

## 四、信号驱动IO模型



## 五、异步IO模型



# Java IO



# Java NIO



# Channel



# Buffer



# Selector