# 1、线程生命周期

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/threadLifeCycle202203211430.png" alt="threadLifeCycle">


# 2、锁的优化策略

锁优化就是一些提高锁的效率的策略，下面以synchronized为例，来介绍优化操作。

1. **锁消除**：编译器 + JVM 会根据代码运行的情况智能判定当前的锁是否必要，如果不必要，就直接把加锁的代码忽略。

2. **偏向锁**：第一个尝试加锁的线程，不会真的加锁，而是进入偏向锁状态（很轻量的标记），直到其他线程也来竞争这把锁，才会取消偏向锁状态，真正进行加锁。

	`1和2的优化思路相同：能不加锁就不加锁`

3. **自旋锁**：真的有多个线程竞争锁的时候，偏向锁状态被消除，此时线程使用自旋锁的方式来尝试进行获取锁。自旋锁能保证让其他想竞争锁的状态尽快获取到锁，付出了一定的CPU 资源

4. **膨胀锁** （无奈之举，严格上说，不能算优化）当锁竞争更加激烈，此时就会从自旋锁状态膨胀成重量级锁（挂起等待锁）

5. **锁粗化**：如果一段逻辑中，需要多次加锁解锁，并且加锁解锁的时候没有其他线程来竞争，此时就会把多组加锁操作，合并到一起。

	粗化就是把 **多组加锁解锁**操作合并成一组。每次加锁解锁操作，都有开销，减少加锁的次数，就能提高效率了。

