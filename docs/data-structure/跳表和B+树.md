# B+树

<img src="image/B+树.png" alt="图片" style="zoom:80%;" />

一般B+树是由多个页组成的**多层级**结构，每个页`16Kb`，对于主键索引来说，最末级的**叶子结点**放行数据，**非叶子结点**放的则是索引信息（主键id和页号），用于加速查询。

B+树利用了**空间换时间**的方式（构造了一批非叶子结点用于存放索引信息），**将查询时间复杂度从O(n)优化为O(lg(n))**。

比方说我们想要查找行数据5。会先从顶层页的record们入手。**record里包含了主键id和页号（页地址）**。关注黄色的箭头，向左最小id是1，向右最小id是7。那id=5的数据如果存在，那必定在左边箭头。于是顺着的record的页地址就到了`6号`数据页里，再判断id=5>4，所以肯定在右边的数据页里，于是加载`105号`数据页。

> MySQL的Innodb的聚簇索引

# 跳表

储存一行行数据，用单链表串起来

<img src="image/单链表.png" alt="单链表" style="zoom: 50%;" />

将**部分**链表结点提出来，再构建出一个新的链表。

<img src="image/两层跳表.png" alt="两层跳表" style="zoom:50%;" />

先查上层的链表，就很容易知道数据落在**哪个范围**，然后**跳到下一个层级里进行查询。**

比如查询id=10的数据，我们先在上层遍历，依次判断1,6,12，很快就可以判断出10在6到12之间，然后往下一跳，就可以在遍历6,7,8,9,10之后，确定id=10的位置。直接将查询范围从原来的1到10，变成现在的1,6,7,8,9,10，算是砍半了。

可以多加几层

<img src="image/三层跳表.png" alt="三层跳表" style="zoom:50%;" />

跳表也是通过**牺牲空间换取时间**的方式提升查询性能。**时间复杂度都是lg(n)**。

# 区别

B+树和跳表的**最下面一层都是存储了所有的数据**，并且是**有序**的，适用于**范围查找**。

## 一、B+树新增数据

当数据库表不断插入新的数据时，为了维持B+树的平衡，B+树会不断分裂调整数据页。

为了简化问题，**假设**一个数据页只能放三条行数据或索引。

加入一条数据，根据数据页会不会满，分为三种情况。

- **叶子结点和索引结点都没满**。这种情况最简单，直接插入到叶子结点中就好了。

<img src="image/B+树新增1.png" alt="B+树新增1" style="zoom:67%;" />

- **叶子结点满了，但索引结点没满**。此时需要拆分叶子结点，同时索引结点要增加新的索引信息。

<img src="image/B+树新增2.png" alt="B+树新增2" style="zoom:67%;" />

- **叶子结点满了，且索引结点也满了**。叶子和索引结点都要拆分，同时往上还要再**加一层索引。**

<img src="image/B+树新增3.png" alt="B+树新增3" style="zoom:67%;" />

## 二、跳表新增数据

跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据。

此时，**是否需要在上面的几层中加入数据做索引呢？**

这个就纯靠**随机函数**了。

理论上为了达到**二分的效果**，每一层的结点数需要是下一层结点数的二分之一。

也就是说现在有一个新的数据插入了，它有`50%`的概率需要在`第二层`加入索引，有`25%`的概率需要在`第三层`加个索引，以此类推，直到`最顶层`。

举个例子，如果跳表中插入数据id=6，且随机函数返回第三层（有25%的概率），那就需要在跳表的最底层到第三层都插入数据。

<img src="image/跳表新增.png" alt="跳表新增" style="zoom:67%;" />

# Mysql的索引为什么使用B+树而不使用跳表？

**B+树**是多叉树结构，每页16k，能存放很多数据，且三层就能存放2kw左右的数据，数据是存放在磁盘的，查一次数据只要2～4次磁盘IO。

**跳表**是链表结构，一条数据一个结点，如果最底层要存放`2kw`数据，且每次查询都要能达到**二分查找**的效果，`2kw`大概在`2的24次方`左右，所以，跳表大概高度在**24层**左右。最坏情况下，这24层数据会分散在不同的数据页里，也即是查一次数据会经历**24次磁盘IO**。

而针对**写操作**，B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此**跳表的写入性能会比B+树要好。**

> `facebook`造了个`rocksDB`的存储引擎，里面就用了**跳表**。直接说结论，它的**写入性能**确实是比innodb要好，但**读性能**确实比innodb要差不少。



# redis的zset为什么使用跳表而不使用B+树或二叉树呢？

redis进行读写数据都是操作**内存**，跟磁盘没啥关系，因此也**不存在磁盘IO**了，所以**层高就不再是跳表的劣势了**。

提到B+树是有一系列合并拆分操作的，换成红黑树或者其他AVL树的话也是各种旋转，目的也是**为了保持树的平衡**。

而跳表插入数据时，只需要**随机一下，就知道自己要不要往上加索引**，根本不用考虑前后结点的感受，也就**少了旋转平衡的开销**。

# 总结

- B+树是多叉平衡搜索树，扇出高，只需要3层左右就能存放2kw左右的数据，同样情况下跳表则需要24层左右，假设层高对应**磁盘IO**，那么B+树的读性能会比跳表要好，因此mysql选了B+树做索引。
- redis的读写全在内存里进行操作，不涉及磁盘IO，同时跳表实现简单，相比B+树、AVL树，**少了旋转树结构的开销**，因此redis使用跳表来实现ZSET，而不是树结构。

# 参考

https://mp.weixin.qq.com/s/7k09qc2dWKR4FhtfMRncpQ