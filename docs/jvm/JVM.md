# 面试题目

## 一、int a = 1 存放在哪？

明确1是字面量，a是变量也是符号引用。

-128 ～ 127都在常量池中，超出的再integer

**a是成员变量**：符号引用a和字面量1都是存储在常量池中的，也即是方法区中。

**a是局部变量**：符号引用a和字面量1都是在栈中的局部变量表中。

## 二、一个对象从加载到JVM，再到被GC清除，都经历了什么过程？

1. 用户创建一个对象，JVM 首先到方法区找对象的类型信息，然后创建对象。

2. JVM 要实例化一个对象，首先要在堆中创建一个对象 -> 半初始化状态

3. 对象首先会分配在堆内存的Eden中，然后经历一次Minor GC，对象如果存活，就会进入S区；在后续的每次 GC 中，如果对象一直存活，就会在 S 区来回拷贝，每移动一次，年龄加 1。-> 年龄超过15就会转入Old。

4. 当方法执行结束后，栈中的指针会先移除掉。

5. 堆中的对象，经过 Full GC，就会被标记为垃圾，然后被 GC 线程清理掉。

## 三、G1垃圾回收的阶段

1. **初始标记**：标记出 GCRoot 直接引用的对象。STW
2. **标记 Region**：通过 RSet 标记出上一个阶段标记的 Region 引用到的 Old 区 Region。
3. **并发标记**：与CMS类似，只是遍历的不是Old区，而是第二步标记出来的Region。
4. **重新标记**：类似CMS。
5. **垃圾清理**：与CMS不同的是，G1 可以采用复制算法，直接将整个 Region 中的对象复制到另一个 Region。而这个阶段，G1 只选择垃圾较多的 Region 来清理，并不是完全清理。

# Java源程序编译运行过程

Java 源文件 → 编译器 → JVM可以理解的字节码文件 .class → JVM解释器/JIT编译器 →机器可以执行的二进制机器码

> 字节码文件
>
> - 不专对特定机器，无需重新编译就可以在不同的机器上运行
> - 以一个字节 8bit 为最小单位储存

# JVM运行机制

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207161425580.jpg" alt="第02章_JVM架构-简图" style="zoom:70%;" />



**线程**

- **线程是进程中执行运算（资源分配）的最小单位**，是进程的一个实体
- 一个进程就是一个程序，多进程是指操作系统能同时运行多个任务（程序）

**执行引擎**

- 将字节码指令解释/编译为对应平台上的本地机器指令

# 预备知识：常量池

存放

- 字面量
- 符号引用

<br>

1. **(Class)常量池**
  - Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），存放编译期生成的各种`字面量`和`符号引用`
  - 每个class文件都有一个class常量池
2. **运行时常量池**（方法区里的重要结构）
  - 运行时常量池存在于内存中，也就是`class常量池被加载到内存之后的版本`，不同之处是：它的字面量可以动态的添加(String.intern())，符号引用可以被解析为直接引用
  - JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，`运行时常量池也是每个类都有一个`。在解析阶段，会把`符号引用替换为直接引用`，解析的过程会去`查询字符串常量池`，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

> 字符串常量池
>
> - ≤1.6 方法区中
> 	- String Pool里放的都是字符串常量
> - ≥1.7 移到了堆中
> 	- 由于String#intern()发生了改变，因此String Pool中也可以存放放于堆内的字符串对象的引用
> - 字符串常量池中的字符串只保存一份

# 对象

```java
public static void main(String[] args) {
    Customer cust = new Customer();
}
```



<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152117217.jpg"/>

## 对象的实例化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203311610240.png" alt="第10章_对象的实例化" style="zoom:50%;" />

### 内存分配

1、指针碰撞

已用内存和未使用内存是分开的，中间由指针隔开

2、空闲列表

有个列表来描述哪些地址的内粗是空闲的

> 内存分配是哪种方式还得看GC的方式，有的GC会造成碎片化就是用空闲列表。

### 判断对应的类是否加载、初始化（加载类元信息）

虛拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。

如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名＋类名为key进行查找对应的.class 文件。如果没有找到文件，则抛出ClassNotFoundException 异常，如果找到，则进行类加载，并生成对应的Class 类对象

> new是开始，构造器后才构建成功。

## 对象的内存布局

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152057836.jpg" alt="第10章_内存布局" />

### 对象头

- 运行时元数据（MarkWord）

	- 哈希值
	- GC分代年龄
	- 锁状态标志
	- 线程持有的锁
	- 偏向线程ID
	- 偏向时间戳

- 类型指针

	指向类元数据InstanceKlass，确定该对象所属的类型
	
- 数组长度

  如果有的话，32bit

> 对象头中的Mark Word（标记字）主要用来**表示对象的线程锁状态**，另外还可以用来配合GC、存放该对象的hashCode；

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207161444658.png"  />

> 为什么从Young GC的对象最多经历15次Young GC还存活就会进入Old区（年龄是可以调的，默认是15）?
>
> 因为用了4个bit去表示分代年龄，那么能表示的最大范围就是0-15。所以这也就是为什么设置新生代的年龄不能超过15，可以通过-XX:MaxTenuringThreshold去调整（最大值为15）

[对象头](https://blog.csdn.net/sumengnan/article/details/125035218)

[锁升级与对象头](https://zhuanlan.zhihu.com/p/537852119)

1、对于偏向锁而言， **一旦在对象头中设置过hashcode， 那么进入同步块时就不会进入偏向锁状态**，会直接跳到轻量级锁，毕竟偏向锁里没有存放hashcode的地方。

2、轻量级锁中，除了锁状态标记位，其他的都变成了一个栈帧中lockRecord记的地址。分代年龄、hashcode等固有属性。这些信息会被存储到对应线程栈帧中的**lockRecord**中。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207161501955.jpg" alt="img" style="zoom:67%;" />

3、重量级锁中，对象头中的markwod，和轻量级锁中的处理类似， 被存入objectMonitor对象的header字段中。

## 对象的访问定位

### 1、直接访问（HotPot采用）

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152136151.jpg" alt="第10章_方式2：使用直接指针访问" style="zoom:45%;" />

### 2、句柄访问

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207152134231.jpg" alt="第10章_方式1：句柄访问" style="zoom:67%;" />

需要专门开辟区间存放句柄，而且效率慢，因为需要先找到句柄，再从句柄找到对象实例数据。

优点：reference中存放稳定句柄地址，对象被移动时只会改变句柄中实例数据指针即可，reference本身不需要被修改。

# JVM内存区域

> 栈管运行，堆管存储

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301347028.png" alt="image-20220330134754626" style="zoom:40%;" />

**线程私有区**【程序计数器、虚拟机栈（Java栈）、本地方法栈】

- 生命周期与线程相同, 依赖用户线程的启动/结束，而创建/销毁在 Hotspot VM 内

**线程共享区**【Java堆（堆空间）、方法区】

- 随虚拟机的启动/关闭而创建/销毁

**直接内存**【不受 JVM GC 管理】

- 不是 JVM 运行时数据区的一部分，但 I/O 可以使用 Native 函数直接分配堆外内存
- 直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。

> 在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。
>
> 这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 
>
> 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。 配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301115606.png" alt="image-20220330111510231" style="zoom: 33%;" />

<br>

## 一、程序计数器 PC寄存器

- 当前线程所执行的字节码的行号（地址）指示器，方便时间片结束后再次回来可以继续执行
- 唯一一个没有规定 OOM（OutOfMemoryError）的区域

<br>

## 二、虚拟机栈（Java栈）

> 存放`局部变量`
>
> - 8种基本数据类型
>
> - 引用数据类型的`引用`

异常：StackOverflow；OOM

栈帧弹出：函数返回或抛出异常

### 1、总体结构

描述java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧（Stack Frame）

参与方法的调用与返回

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301118092.png" alt="image-20220330111823493" style="zoom: 33%;" />

#### 2、栈帧

- 栈中`存储数据的基本单位`，一个栈帧对应一个方法

#### 栈帧存储的数据

方法在本次执行过程中所用到的局部变量、动态链接、方法出口等信息。栈帧中主要保存3 类数据：

- 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量，**局部变量**。
- 栈操作（Operand Stack）：记录出栈、入栈的操作。
- 栈帧数据（Frame Data）：包括类文件、方法等等。

#### 结构

- **局部变量表**：定义为一个数字数组，存储方法参数和方法体内声明的`局部变量`
	- 其大小是编译期确定下来的
	- 8种基本数据类型、引用类型的引用（reference）、returnAdress类型
	- 都是数
- **操作数栈**（表达式栈）：保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- **动态链接**（指向运行时常量池中方法的引用）
	- 字节码文件中，所有变量和方法引用都作为符号引用保存在class常量池中
	- 动态链接就是为了将这些符号引用转换为调用方法的直接引用
- **方法返回地址**（方法正常退出或者异常退出的定义）
- 一些附加信息：例如对程序调试提供支持的信息

### 2、面试题

1. **举例栈溢出的情况 StackOverflowError**

	- 大量递归
	- 过多的全局变量
	- 数组、List、map数据是否过大

	- 通过-Xss设置栈的大小；OOM

2. **内存溢出的情况OOM**

	- 内存溢出是由于**没被引用的对象（垃圾）过多造成JVM没有及时回收**，导致的内存溢出。
	- 是否应用中的**类中和引用变量过多使用了Static修饰** 如public staitc Student s；
	- 是否应用中使用了大量的递归（**递归中有新建对象**）
	- 检查是否**有数组，List，Map中存放的是对象的引用**，因为这些引用会让对应的对象不能被释放
	- 检查是否使用了“非字面量字符串进行 + ”的操作。因为 String 类的内容是不可变的，每次运行 " + " 就会产生新的对象，如果过多会造成新 String 对象过多，从而导致 JVM 没有及时回收而出现内存溢出。

	```java
	String s1 = "My name";
	String s2 = "is";
	String s3 = "xuwei";
	String str = s1 + s2 + s3 +.........;
	// 这是会容易造成内存溢出的
	
	String str =  "My name" + " is " + " xuwei" 
	    + " nice " + " to " + " meet you"; 
	// 但是这种就不会造成内存溢出。
	// 因为这是”字面量字符串“，在运行"+"时就会在编译期间运行好。
	// 不会按照JVM来执行的。
	```

	

3. 调整栈的大小，就能保证不出现溢出吗？不能

4. 分配的栈内存越大越好吗？不是

5. 垃圾回收会涉及虚拟机栈吗？不会

6. 方法中定义的局部变量是否线程安全？

	- 一个线程安全，多个线程且不考虑同步问题会存在安全问题

<br>

## 三、本地方法栈

>虚拟机栈为 Java 方法服务，而本地方法栈为 Native 方法服务。

`HotSpot VM 将本地方法栈和虚拟机栈合二为一`

<br>

## 四、堆

> **TIP**：**new 的都在堆中**
>
> 创建的`实例对象实体`和`数组`都保存在堆中，也是 GC 的重要区域
>
> 实例变量
>
> NOTE：静态引用对应的`对象实体`也始终都在堆中
>
> 数组也是new出来的

1.8后加上`字符串池`和`静态变量（引用名）`

所有线程共享 Java 堆，但是还可以划分`线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）`

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301316327.png" alt="image-20220330131644568" style="zoom:40%;" />

> 分代是为了**优化GC性能**
>
> - 不同对象生命周期不同
> - Eden区主要是生命周期很短的对象，经常GC
> - 老年代主要是生命周期很长的对象，不经常GC
> 	- 例如：IOC容器对象、线程池对象、数据库连接池对象等等
> - 幸存者区作为二者之间的过渡地带



### 1、新生代young

- **Eden**：Java 新对象的出生地
	- `如果新创建的对象占用内存很大，则直接分配到老年代`
	- 当 Eden 内存不够的时候会触发 MinorGC，对新生代区进行 GC
- **ServivorFrom**：上一次 GC 的幸存者，作为这一次 GC 的被扫描者
- **ServicorTo**：保留了一次 MinorGC 过程中的幸存者
	- to 和 from 不是固定的
- **MinorGC** 的过程（复制 -> 清空 -> 互换，复制算法）
	- eden、from 中存活的对象复制到 to，年龄 + 1
		- to 满了就直接进 old 
		- 年龄到了15，即进行了15次 GC，进 old
	- 清空 eden、from 中的对象
	- to 和 from 互换指针，即原 to 成为下一次 GC 的 from

> 复制必交换，谁空谁为 to
>
> QA：为什么有两个survivor区？复制算法，避免碎片化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203310942440.png" alt="image-20220331094237355" style="zoom:50%;" />

### 2、老年代old

old 中的对象比较稳定，Major GC 不会频繁执行

MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

> **TIP**
>
> Minor GC：清理 young
>
> Major GC：清理 old
>
> Full GC：清理整个堆空间
>
> 有时FGC和Major GC说的是一个

<br>

### 3、TLAB（Thread Local Allocation Buffer，TLAB）

线程私有缓存区，在Eden区分配（`1%`），但其他线程也可以访问，只是不需要加锁了，也可以避免了线程安全问题

JVM 将 TLAB 作为内存分配的首选

<br>

### 4、堆是分配对象存储的唯一选择吗？不是

如果经过`逃逸分析（Escape Analysis）`后发现，一个对象并没有逃溢出方法的话，那么就**可能被优化成栈上分配**。

如何将堆上的对象分配到栈，需要使用逃逸分析手段

逃逸分析：

- 一个对象在方法中被定义后，只在方法内部使用，则认为没有逃逸
- 一个对象在方法中被定义后，被外部方法所引用，则认为发生逃逸
	- 如作为调用参数传递到其他地方
	- `成员变量赋值`、`方法返回值`、`实例引用传递`

>快速判断是否发生了逃逸，看 new 的**对象实体**是否有可能在方法外被调用
>
>开发中能使用局部变量的，就不要使用在方法外定义。

### 5、逃逸分析之代码优化

#### 栈上分配

> 将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

#### 同步省略

> 如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

#### 标量替换/分离对象

> 有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储在CPU寄存器中。

**标量(Scalar)** 是指**一个无法再分解成更小的数据的数据**。Java中的原始数据类型就是标量。

还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207021636657.png" alt="20200604133852140"  />

**Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了**。那么标量替换有什么好处呢?就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。标量替换为**栈上分配**提供了很好的基础。

<br>

## 五、方法区

### 1、存放内容（类信息、字节码信息、代码片段）

- 类(型)信息：类class、枚举enum、接口interface、注解annotation
	- 类型的全名：包名.类名
	- 父类的完整有效名
	- 修饰符
	- 直接接口的一个有序列表
- 域(Field)信息、方法信息
- 静态变量/类变量（`引用名`）：non-final的类变量（`1.7及之后被移入堆`）
- 运行时常量池（`其中的字符串常量池StringTable在1.7及之后移入了堆`）
- 即时编译器编译后的代码缓存

> **TIP**：全局常量 static final
>
> 全局常量在编译时就会被分配

### 2、概念

- 标准层面：方法区（Method Area）
- 具体实现层面：
	- ≤1.7 永久代（PermGen）：名义上属于堆，实现上不属于堆
		- 1.7 中就已经将`字符串常量池StringTable和静态变量移入堆中`了
	- ≥1.8 元空间（MetaSpace）
		- 元空间使用本地内存
		- 类的元数据（描述代码间关系联系的数据）存入 native memory

<br>

### 3、永久代为什么被元空间替换？

1. 为永久代设置空间大小是很难确定的
2. 堆永久代进行调优很困难

### 4、StringTable为什么调整

永久代回收效率低，在FGC的时候才会触发，会导致StringTable回收效率不高，而开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。当到堆中，能及时回收内存。

### 5、方法区的垃圾回收

主要针对两部分

- 常量池中废弃的常量
- 不再使用的类型

永久代也是会有垃圾回收的

<br>

## Java栈、堆和方法区的关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301255028.png" alt="image-20220330125507742" style="zoom: 33%;" />

```java
class Test {
    static Person staticPer = new Person();
    Person instancePer = new Person();
    void foo() {
        Person localPer = new Person();
    }
}
/*
	new Person()	无论什么情况始终都在堆中
	staticPer		静态变量：≤1.6方法区，≥1.7堆
	instancePer		实例变量：随着Test的对象实例存在堆
	localPer		局部变量：存在foo()方法栈帧的局部变量表
*/
```



<br>

# JVM类加载机制

加载、验证、准备、解析、初始化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301024818.png" alt="image-20220330102400457" style="zoom:67%;" />

1. 加载

	- 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口

2. 验证

	- 确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求

3. 准备

	- 在方法区中分配这些变量所使用的内存空间

	```java
	public static int i = 8080;
	// 变量在准备阶段的默认值为0，在编译（初始化）阶段才会显式赋值8080
	public static final int i =8080;
	// final在准备阶段就会赋值
	```

4. 解析

	- 虚拟机将常量池中的符号引用替换为直接引用的过程
		- 符号引用：引用的目标不一定要加载在内存中
		- 直接引用：引用的目标必定已经在内存中了

5. 初始化

	TIP：不会执行初始化的情况

	- 通过子类引用父类的静态字段，只会触发父类的初始化
	- 定义对象数组
	- 通过类名获取 Class 对象
	- 通过 Class.forName 加载指定类时，指定参数 initialize = false
	- 通过 ClassLoader 默认的 loadClass 方法


## 类加载
**启动类加载器 Bootstrap ClassLoader**

- 加载 **$JAVA_HOME/jre/lib** 下的 jar 包，如 rt.jar

**扩展类加载器 Extension ClassLoader**

- 加载\$JAVA_HOME/jre/lib/*.jar 、-Djava.ext.dirs 参数指定目录下的 jar 包、**$JAVA_HOME/jre/lib/ext/classes** 目录下的 class

**应用程序类加载器 Application ClassLoader**

- 加载用户路径 classpath 中指定的 jar 包及目录中的 class

- 自定义类加载器：程序员自己开发一个类继承 java.lang.ClassLoader， 定制类加载方式
	- 加载用户指定目录下的，挂载应用类加载器

### 双亲委派机制

- 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求**委派给父类**去完成，
- 每一个层次类加载器都是如此，因此所有的加载请求都应该传送到**启动类加载器**中，
- 只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301035804.png" alt="image-20220330103519857" />

> **TIP**
>
> - **避免类的重复加载**：父加载器加载了一个类，就不必让子加载器再去查找了。同时也保证了在整个 JVM 范围内全类名是类的唯一标识。
> 	- 比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。
> - **安全机制**：避免恶意替换 JRE 定义的核心 API
> 	- 比如自定义一个 java.lang.String 类，最终加载的还是启动类加载器加载的String



<br>

# 垃圾回收机制

作用区域：方法区和堆，重点是堆

从次数上

- 频繁收集Young区
- 较少收集Old区
- 基本不动Perm区

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/GC202204051338554.png" alt="image-20220405133753426" style="zoom: 33%;" />

## 一、标记阶段：如何判断对象死亡

### 1、引用计数法

记录对象被引用的情况

引用一次计数+1，解除引用-1；

可能会循环引用，导致计数器无法归零

### 2、可达性分析、根搜索法 GC Roots

`解决循环引用的问题，防止内存泄漏`

核心原理：判断一个对象，是否存在从『堆外』到『堆内』的引用。

以`根对象集合（GC Roots）`为起点，从上至下的方式搜索被根对象集合所连接的目标对象是否可达。搜索的路径称为`引用链（Reference Chain）`

- 如果在 GC Roots 和一个对象之间没有可达路径，则称该对象不可达
- 不可达对象经过至少两次标记后，如果仍是可回收对象，则将面临回收

> **GC root设置为所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用**

#### GC Roots 的对象包括：

- **Java栈中引用的对象**（比如引用类型的引用对应的那个对象，`Person person的person`）
	- 各个线程被调用方法中使用的参数、局部变量等
- **本地方法栈中引用的对象**
- 方法区中
	- 类引用类型**静态变量/类变量引用的对象**（1.7之后堆中）
	- **常量引用的对象**：字符串常量池里的引用的对象（1.7之后堆中）
- **被synchronized持有的对象**
- 基本数据类型对应的Class对象，常驻异常对象、系统类加载器

根据选择的GC收集器和当前回收的内存区域不同，还可以有其他对象“临时性”加入，比如：分代收集和局部回收

> **TIP**
>
> Root 采用栈方式存放变量和指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root

由于枚举根节点需要停顿，所以GC进行时必须Stop The World (STW，暂停所有线程)

## 对象的finalization机制

Java语言提供了对象终止（finalization）机制来允许开发人员提供`对象被销毁之前的自定义处理逻辑`

**垃圾回收对象之前，总会先调用这个对象的finalize()方法**

finalize允许在子类中被**重写**，用于在对象回收时进行资源释放，比如：关闭文件、套接字、数据库连接等

**不要主动调用finalize，应交给垃圾回收**，因为

- 在finalize时可能会导致对象复活
- finalize的执行时间没有保障，完全由GC线程决定，极端下，若不GC，则finalize不会执行
- 一个糟糕的finalize会严重影响GC性能

### 1、JVM中对象的三种状态

- 可触及的：可达
- 可复活的：不可达，但是对象可能在finalize中复活
- 不可触及的：没复活；不可触及的对象不可能被复活，因为`finalize只会被调用一次`

### 2、GC Roots中的两次标记

1. 没有引用链，第一次标记
2. 判断是否有必要执行finalize
	- 没有重写finalize、或finalize已经被调用过了，则对象不可触及
	- 重写了finalize且也没调过，JVM会创建一个低优先级的Finalizer线程触发finalize方法
	- 若finalize中建立了联系，但是之后再次断开引用链，finalize不会再触发

## 二、清除阶段：垃圾回收算法

> **清除**
>
> 不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放

### 1、标记-清除（Mark-Sweep）

**标记**：从根节点开始遍历，标记所有被引用的对象（可达对象）

**清除**：对堆内存从头到尾进行线性遍历，回收没有标记的对象

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011000580.png" alt="第14章_标记-清除算法" style="zoom:33%;" />

**缺点**

- 效率不算高
- 清理出来的空间内存不连续，`内存碎片化严重`，后续可能发生大对象找不到可用空间
- 需要维护一个空闲列表

### 2、复制（Copying）

为了解决标记清除的内存碎片化的缺陷提出

将**内存空间分为两块**，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存大角色，完成垃圾回收

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011015298.png" alt="第14章_复制算法" style="zoom:33%;" />

**优点**

- 实现简单，运行搞笑
- 空间连续，不会碎片

**缺点**

- 需要两倍大空间
- 存活对象多多话，效率会低

**特别的**

特别适合垃圾对象很多，存活对象很少的场景，例如：Young区的survior0和survior1

### 3、标记-压缩/整理（Mark-Compact）

结合以上两种算法，避免缺陷

标记后将存活对象移向内存的一端，按序排放，然后清除端边界外的对象

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011022855.png" alt="第14章_标记-压缩算法" style="zoom:33%;" />

**缺点**

- 效率低于复制算法
- 移动对象时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序

### 分代收集

根据不同分代区域，选择合适的算法

- 新生代：生命周期短，存活对象少
	- 使用复制算法，所以存在from和to区
- 老年代：区域大，生命周期长，回收频率不高
	- 使用标记清除和标记压缩的混合实现
		- Mark阶段的开销与存活对象的数量成正比
		- Sweep阶段的开销与所管理区域的大小成正比
		- Compact阶段的开销与存活对象的数据成正比

### 分区收集

将整个堆空间划分为连续的不同小区间region，每个小区间独立使用，独立回收，可以控制一次回收多少个小区间

### 增量收集

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿（STW），那么就可以**让垃圾收集线程和应用程序线程交替执行**。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过`对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。`

**缺点**：交替执行，系统吞吐量下降

## 垃圾回收的相关概念

### 1、Systenm.gc()的理解

默认情况下，System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象的内存。

System.gc()有个免责声明，无法保证对垃圾收集器的调用。

### 2、内存溢出和内存泄露

#### a>内存溢出OutOfMemoryError

**内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收**，导致的内存溢出。

或虚拟机堆内存设置不够。

具体原因

- 是否应用中的类中和引用变量过多使用了Static修饰，如public staitc Student s；
- 是否应用中使用了大量的递归（递归中有新建对象）
- 检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放
- 检查是否使用了“非字面量字符串进行 + ”的操作。因为 String 类的内容是不可变的，每次运行 " + " 就会产生新的对象，如果过多会造成新 String 对象过多，从而导致 JVM 没有及时回收而出现内存溢出。

```java
String s1 = "My name";
String s2 = "is";
String s3 = "xuwei";
String str = s1 + s2 + s3 +.........;
// 这是会容易造成内存溢出的

String str =  "My name" + " is " + " xuwei" 
    + " nice " + " to " + " meet you"; 
// 但是这种就不会造成内存溢出。
// 因为这是”字面量字符串“，在运行"+"时就会在编译期间运行好。
// 不会按照JVM来执行的。
```

> OOM之前一定会触发GC，不够才会OOM

#### b>内存泄漏Memory Leak

`对象不会再被程序用到，但是GC又不能回收`

由于 Java 中采用可达性分析，不存在因为循环引用不能被GC的问题。

**⻓⽣命周期的对象持有短⽣命周期对象的引⽤就很可能发⽣内存泄露**，尽管短⽣命周期对象已经不再需要，但是因为⻓⽣命周期对象持有它的引⽤⽽导致不能被回收

例如：

- 一个**外部类的实例对象**的方法**返回**了一个**内部类的实例对象**，这个内部类对象被长期引用，**即时外部类不再使用**，由于内部类还在使用的原因，这个**外部类对象不能够被回收**
- 缓存系统：**加载了一个对象放在缓存中**（例如放在一个全局map对象中），但是一直不用，这个对象一直被缓存引用却没被使用
- 单例模式：单例的生命周期和应用程序一样长，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象不能被回收
- 一些提供close的资源未被关闭，GC也不会回收

### 3、Stop The World

GC过程中，产生应用程序的停顿，停顿时整个应用程序线程都会被暂停，没有任何响应

所有GC器都会发生STW，就算G1也会，只是时间被缩短了很多

### 4、垃圾回收的并行与并发

并发

- 多个事情，在**同一时间段内同时发生**（因为**时间片快速切换**）
- 多个任务之间时互相抢占资源

并行

- 多个事情，在**同一时间点上同时发生**
- 多个任务之间不互相抢占资源

> 只有在多CPU或者一个CPU多核多情况下，才会发生并行
>
> 否则，看似同时发生的事情，其实都是并发
>
> 并行一定是并发，并发不一定是并行

**垃圾回收中**

并行（Parallel）

- 多条垃圾回收器并行工作

串行（Serial）

- 一条垃圾回收器

并发（Concurrent）

- 用户线程和垃圾回收线程同时执行（不会是完全并行，会交替执行）

### 5、安全点与安全区域

**安全点**：并非所有地方都能停顿开始GC，只有特定位置才能停顿下来开始GC

如何在GC发生时，如何保障所有线程都跑到最近的安全点停顿下来呢？

- **抢占式中断**（没有虚拟机采用）

	首先中断所有线程，如果有线程不在安全点，就回复线程，让线程跑到安全点

- **主动式中断**

	设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果为真，则将自己中断挂起

**安全区域**

在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的，是扩展了的安全点

### 6、Java的四类引用类型 — 强软弱虚

#### 强引用 — 不回收

在 Java 中最常见(99%)的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。

当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。

因此强引用是`造成 Java 内存泄漏`的主要原因之一。

#### 软引用 — 内存不足即回收

软引用需要用 SoftReference 类来实现，对于**只有软引用的对象**来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。

#### 弱引用 — 发现即回收

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于**只有弱引用的对象**来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。

> 软、若都适合保存缓存数据

#### 虚引用 — 对象回收跟踪

虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。

当准备回收一个对象时，如果发现还有虚引用，会在回收对象前，将这个虚引用加入引用队列，可以通过扫描队列来通知对象的回收情况等；这个队列是在创建虚引用的时候一同创建的。

```java
Object obj = new Object();
ReferenceQueue<Object> rq = new ReferenceQueue<Object>();
PhantomReference<Object> pf = new PhantomReference<Object>(obj,rq);
obj=null;
System.out.println(pf.get());//永远返回null
System.out.println(pf.isEnqueued());//返回是否从内存中已经删除
System.gc();
TimeUnit.SECONDS.sleep(6);
System.out.println(pf.isEnqueued());
        
null
false
true
```

<br>

补：终结器引用

用于实现对象的finalize()方法，配合引用队列使用

## 三、垃圾回收器

### 分类

线程数：

- 串行
- 并行：只要并行就会STW

工作模式：

- 并发式：交替进行，尽量减少停顿时间
- 独占式：一旦运行，就停止应用程序中所有用户线程

碎片处理方式：

- 压缩式：回收后，堆存活对象进行压缩整理，消除回收后的碎片
	- 再分配对象空间使用：指针碰撞
- 非压缩式：不进行压缩整理
	- 再分配对象空间使用：空闲列表

工作的内存区间：新生代和老年代

### 性能指标

- 吞吐量：运行用户代码的时间C占总运行时间M的比例 C/M
- 暂停时间/延迟：执行垃圾收集时，程序的工作线程被暂停的时间N = M - C
- 内存占用：Java堆区所占内存大小

> 吞吐量优先：会增加每次暂停时间，保证垃圾回收完，减少暂停的次数
>
> - 后台运算场景
>
> 暂停时间有限：会增加暂停次数，多次暂停区回收
>
> - 于用户交互的场景

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204042216784.png" alt="第17章_吞吐量与暂停时间" style="zoom: 33%;" />

### 组合关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204042143693.png" alt="第17章_垃圾收集器组合" style="zoom: 33%;" />

连线表示可以搭配使用

Serial Old 作为 CMS 出现“Concurrent Mode Failure”失败后的后备预案

红色虚线：JDK8弃用，JDK9移除

绿色虚线：JDK14弃用

青色框框：JDK14删除

选择针对具体应用最合适的收集器

> G1：整堆收集器

### 1、Serial回收器：串行、响应速度优先

Serial：复制算法、串行回收、STW机制（收集时必须暂停其他工作线程）

Serial Old：串行、STW、标记-压缩

优势：简单高效

运行在Client模式下的默认收集器

可以手动指定

### 2、ParNew回收器：并行、响应速度优先

Serial的多线程版本；Par并行，New新生代

复制算法、STW机制

很多JVM运行在Server模式下的新生代的默认

可以手动指定、设置线程数量

### 3、Parallel回收器：吞吐量优先、并行

Parallel Scavenge：复制、并行、STW

- 与ParNew相比，可以达到可控制的吞吐量，其`自适应调节策略`（动态调节）是重要区别

使用环境：

- 后台运算，不需要太多交互
- 批量处理、订单处理、工资支付、科学计算

Parallel Old：标记-压缩、并行、STW

Java8中默认

可以手动指定（新生代的和老年代的会互相激活）、设置年轻代线程数、最大停顿时间、垃圾收集时间占总时间的比例、启动/关闭自适应调节策略

### 4、CMS回收器：低延迟（响应速度优先）、并发

Concurrent-Mark-Sweep、强交互应用、标记清除、尽可能缩短停顿时间、也会有STW时间

HotSpot中第一款真正意义上的**并发收集器**

#### a>工作机制过程

- **初始标记**：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程
- **并发标记**：进行 GC Roots 跟踪的过程，和用户线程一起工作，`不需要暂停工作线程`。
- **重新标记**：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
- **并发清除**：清除 GC Roots 不可达对象，和用户线程一起工作，`不需要暂停工作线程`。

由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。

> **为什么低延迟**：由于工作机制，耗时的可以一起工作，不耗时的STW

#### b>优点

并发收集、低延迟

#### c>弊端

- **会产生内存碎片**（标记清除）
	- 为什么不标记整理？标记整理的时候，用户线程无法继续执行
- **对CPU资源非常敏感**：并发阶段不会导致用户停顿，但是会因为占用线程而导致程序变慢
- **无法处理浮动垃圾**：并发标记阶段如果产生新的垃圾对象，CMS无法对其进行标记，会导致无法被及时回收，只能下一次
- CMS运行期间预留的内存无法满足程序需要，就会“**Concurrent Mode Failure**”，而后会临时启用Serial Old来收集，Serial Old还是最差的性能

#### d>参数设置

指定回收任务：会默认打开ParNew

设置堆内存使用率的阈值，到达阈值开始回收

指定执行完FullGC后进行压缩整理、还可以设置多少次FullGC后进行压缩整理

设置CMS线程数

### Serial、Parallel、CMS有什么不同？

最小化地使用内存和并行开销：Serial

最大化应用程序的吞吐量：Parallel

最小化GC的中断或停顿时间：CMS

### 5、G1回收器：区域化分代式、优先级区域回收、响应速度优先

Garbage First

目标：**在低延迟可控的情况下获得尽可能高的吞吐量**

- 侧重于回收垃圾最大量的区间，所以叫Garbage First

JDK9 之后的默认，取代了 CMS 及 Parallel + Parallel Old组合

JDK8 中需要 -XX:+UseG1GC 来启动

#### a>优势

- **并行与并发**
	- 并行性
	- 并发性
- **分代收集**
	- 把堆内存划分成很多不相关的区域Region（物理上不连续），使用不同的Region来表示Eden、to、from、old区；

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/JVM202204051351656.jpeg" alt="IMG_A07C135AC2E1-1" style="zoom:50%;" />

- **空间整合**
	- 回收以Region为基本单位，`Region之间是复制算法`，但`整体上`可以看作是`标记压缩`，避免碎片化
- **可预测的停顿时间模型**（软实时 soft real-time）
	- 让使用者明确指定一个长度为 M 的时间片段内，消耗在 GC 的时间不超过 N  
	- 分区后，可以选择部分region回收
	- 后台有个优先级列表，根据允许的收集时间，优先回收价值最大的Region（回收可获得的空间大小及时间），获取尽可能高的收集效率
	- 想比与CMS，G1未必能做到CMS在最好情况下的延迟时间，但是最差情况下性能更好

#### b>参数设置

指定G1、每个Region的大小、最大GC停顿时间指标、STW时GC线程数、并发标记的线程数、触发并发GC周期的java堆占用率

#### c>适用场景

**针对具有大内存、多处理器的机器**；在普通大小的堆里表现不是那么惊艳

比CMS效果好的情况

- 超过50%的堆被活动数据占用
- 对象分配频率或年代提升频率变化很大
- GC停顿时间过长

#### d>分区Region

Region的身份不是固定的，谁占用就是谁

H区主要用于存储大对象，超过0.5个Region就放到H区；一个放不下就找连续的H区；实在不行就FullGC

**每个Region使用指针碰撞的方式存放数据**

#### e>回收过程

- 年轻代GC（Young GC）
- 老年代并发标记过程（Concurrent Marking）
- 混合回收（Mixed GC）：包括年轻代GC和老年代GC
- （如有需要，也存在FullGC，针对GC的评估失败提供了一种失败保护机制，强力回收）

顺时针：young gc -> young gc + concurrent mark -> mixed gc

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/G202204051410567.png" alt="第17章_G1-GC垃圾回收过程" />

**Remembered Set**

一个region中的对象可能被其他region中的对象引用，是否需要扫描整个堆，其他分代收集器也存在这样的问题，如何在回收新生代的时候不同时扫描老年代？

解决方法：

无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描：

> - 每个region都有一个对应的remembered set记忆集
> - 每次Reference类型数据写操作时，都会产生一个write Barrier暂时中断操作；
> - 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）
> - 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered set中；
> - 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered set：就可以保证不进行全局扫描，也不会有遗漏。

##### 年轻代GC

首先G1停止应用程序的执行 (stop-The-world），G1创建回收集(Collection set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。

- 扫描根

- 更新RSet记忆集：保证Rset中的数据准确性
	- RSet需要线程同步，开销大，不能实时更新，需要一个脏卡表队列dirty card queue先保存被其他区域引用的关系

- 处理RSet

- 复制算法

- 处理引用：空Eden，Eden交成空的，那它就变成了无主Region，因此会被记灵到空链表中，等待不一次效分配

##### 老年代并发标记过程

- 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。

- 根区域扫描 (Root Region Scanning)：主要扫描哪些老年代对象是可达的，在进行YGC的时候会移动survivor区，移动之后就找不到哪些老年代对象时可达的了

- 并发标记

- 再次标记

- 独占清理：一个统计计算过程，不涉及垃圾清理

- 并发清理

##### 混合回收 Mixed GC

老年代多的时候，触发，回收部分老年代

##### 可选的过程：FullGC

导致FullGC的原因：

- 没有足够的空间来晋升（加大堆空间
- 并发处理过程完成前空间耗尽（调小触发GC周期的Java堆占用阈值
- 最大GC停顿时间太短，导致在规定时间间隔内无法完成垃圾回收

# JVM调优

**对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。**

## 一、堆大小设置

`-Xms`：设置初始堆内存分配大小，默认为物理内存的 1 / 64
`-Xmx`：设置最大内存分配大小，默认为物理内存的 1 / 4
`-XX:+PrintGCDetails`：输出相信的GC处理日志

**针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;**

## 二、堆内存分配比例

年轻代和年老代将根据默认的比例（1：2）分配堆内存， 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。

比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了**防止年轻代的堆收缩**，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

> 1）更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC
>
> 2）更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率

