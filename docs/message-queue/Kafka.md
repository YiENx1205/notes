# 简问

## Kafka为什么吞吐量高

kafka的生产者采用的是**异步发送消息机制**，当发送一条消息时，**消息井没有发送到Broker而是缓存起来**，然后直接向业务返回成功，当**缓存的消息达到一定数量时再批量发送给Broker**。这种做法**减少了网络io**，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致消息丢失，业务出错，所以理论上katka利用此机制提高了性能却降低了可靠性。

## Kafka的Pull和Push分别有什么优缺点

1. **pull**表示消费者主动拉取，可以批量拉取，也可以单条拉取，所以pull可以由消费者自己控制，**根据自己的消息处理能力**来进行控制，但是消费者不能及时知道是否有消息，**可能会拉到的消息为空**
2. **push**表示Broker主动给消费者推送消息，所以肯定是**有消息时才会推送**，但是消费者不能按自己的能力来消费消息，推过来多少消息，消费者就得消费多少消息，所以**可能会造成网络堵塞**，消费者压力大等问题

## Kafka高效文件存储设计特点

1. Kafka 把 topic 中—个parition 大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完的文件，减少磁盘占用。
2. 通过索引信息可以快速定位 message 和确定response 的最大大小。
3. 通过 index 元数据全部映射到memory，可以避免 segment file 的 10磁盘操作。
4. 通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小，

## Kafka与传统消息系统之间有三个关键区别

1. Kafka **持久化日志**，这些日志可以被重复读取和无限期保留

2. Kafka 是一个**分布式系统**：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性

3. Kafka 支持**实时的流式处理**

## Kafka的消费者如何消费数据

消费者每次消费数据的时候，消费者都会记录消费的物理**偏移量（offset）**的位置等到下次消费时，会接着上次位置继续消费

## Kafka消费者负载均衡策略

一个消费者组中的一个分片对应一个消费者成员，他能保证每个消费者成员都能访问，如果组中成员太多会有空闲的成员

## kafaka生产数据时数据的分组策略

生产者決定数据产生到集群的哪个 partition 中，每一条消息都是以（key， value）格式，key是由生产者发送数据传入，所以生产者（key）决定了数据产生到集群的哪个 partition

## Kafka中是怎么体现消息顺序性的

katka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1。

# Kafka的分区partition

https://blog.csdn.net/ATYtian/article/details/125647322