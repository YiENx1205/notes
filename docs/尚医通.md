项目名称：名医汇预约挂号平台

**开发环境**：IDEA+JDK1.8+ MySQL5.7

**技术选型**：Sping+SpringBoot+SpringCloud+mysql+MybatisPlus+Redis+MongoDB +RabbitMQ+Vue+elementUI

**项目描述**：名医汇预约挂号平台是近年来开展的一项便民就医服务，旨在缓解看病难、挂号难的就医难题，让患者能够随时随地轻松挂号！采用SpringCloud微服务架构和前后端分离技术，后台管理系统分为医院设置，数据字典，用户管理，订单管理，统计管理5个模块，前台用户系统分为：医院详情，用户登录，就诊人管理，预约挂号，就医提醒模块。

**责任描述**：

1. 参与后台需求分析，功能实现的讨论； 
2. 医院设置模块，医院设置与医院列表的增删改查。 
3. 数据字典模块，对数据字典树形显示，excel导入，导出接口开发。 
4. 前台用户登录功能，手机验证码，微信扫描登录接口开发。 
5. 前台用户实名认证与就诊人管理的增删改查。 
6. 订单管理模块订单列表，详情的查看。 

**技术描述**：

1. 基于MyBatisPlus实现数据的增删改查； 
2. 通过redis配置类与Cacheable注解实现数据字典中数据的缓存,提高查询效率; 
3. 通过EasyExcel实现数据字典的导入导出； 
4. 基于SpringCloud中Feign组件实现远程调用，gateway配置网关； 
5. 基于MongDB实现在医院基本信息，科室信息，排班信息的存储，结合Springboot对数据进行查看功能的编码; 
6. 主要第三方API：阿里云短信，微信授权，阿里云OSS云存储; 
7. 使用swagger2进行接口测试。



---



# 模块架构初步

hospital-manage：医院接口模拟端（已开发，直接使用）

yygh-parent：根目录，管理子模块：

- common：公共模块父节点
	- common-util：工具类模块，所有模块都可以依赖于它
	- rabbit-util：rabbitmq业务封装
	- service-util：service服务的工具包，包含service服务的公共配置类，所有               service模块依赖于它

- server-gateway：服务网关

- model：实体类模块

- service：api接口服务父节点
	- service-hosp：医院api接口服务
	- service-cmn：公共api接口服务
	- service-user：用户api接口服务
	- service-order：订单api接口服务
	- service-oss：文件api接口服务
	- service-sms：短信 api接口服务
	- service-task：定时任务服务
	- service-statistics：统计api接口服务
	- service-client：feign服务调用父节点
	- service-cmn-client：公共api接口
	- service-hosp-client：医院api接口
	- service-order-client：订单api接口
	- service-user：用户api接口

# Swagger2

编写和维护接口文档是每个程序员的职责，根据Swagger2可以快速帮助我们编写最新的API接口文档，再也不用担心开会前仍忙于整理各种资料了，间接提升了团队开发的沟通效率。

常用注解

swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。

@Api：修饰整个类，描述Controller的作用

@ApiOperation：描述一个类的一个方法，或者说一个接口

@ApiParam：单个参数描述

@ApiModel：用对象来接收参数

@ApiModelProperty：用对象接收参数时，描述对象的一个字段

@ApiImplicitParam：一个请求参数

@ApiImplicitParams：多个请求参数



配置在service_util中

下列地址就是api操作地址

`http://localhost:8201/swagger-ui.html`

# 统一返回定义

在common_uitl中定义Result和ResultCodeEnum

com.yienx.yygh.common.result



# 条件查询vo

vo类封装条件值

然后编写controller

```
@RequestBody(required = false) HospitalSetQueryVo hospitalSetQueryVo
```

将表单值传到对应的对象中，false表示可以为空



# 全局异常处理

spring boot 默认情况下会映射到 /error 进行异常处理，但是提示并不十分友好，下面自定义异常处理，提供友好展示。

common-util里创建GlobalExceptionHandler

## 自定义异常

```java
try {
    int a = 1/0;
} catch (Exception e) {
    throw new YyghException("除数不能为0", 201);
}
// 
@ExceptionHandler(YyghException.class)
@ResponseBody
public Result error(YyghException e) {
    e.printStackTrace();
    // return Result.fail();
    return Result.build(e.getCode(), e.getMessage());
}
// ResponseBody
{
  "code": 201,
  "message": "除数不能为0",
  "data": null,
  "ok": false
}
```



# 日志

日志记录器（Logger）的行为是分等级的。如下表所示：

分为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL

从左往右显示的越全

默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别

```properties
# 设置日志级别
logging.level.root=WARN
```



这种方式只能将日志打印在控制台上

## 配置日志

resources/logback-spring.xml



# 数据字典



# SpringCache + Redis 缓存数据

## 注解

#### @Cacheable

根据方法对其返回结果进行缓存，下次请求时，如果缓存存在，则直接读取缓存数据返回；如果缓存不存在，则执行方法，并把返回的结果存入缓存中。一般用在查询方法上。

| 属性/方法名 | 解释                                             |
| ----------- | ------------------------------------------------ |
| value       | 缓存名，必填，它指定了你的缓存存放在哪块命名空间 |
| cacheNames  | 与 value 差不多，二选一即可                      |
| key         | 可选属性，可以使用 SpEL 标签自定义缓存的key      |



### @CachePut

使用该注解标志的方法，每次都会执行，并将结果存入指定的缓存中。其他方法可以直接从响应的缓存中读取缓存数据，而不需要再去查询数据库。一般用在新增方法上。

内部属性同上

### @CacheEvict

使用该注解标志的方法，会清空指定的缓存。一般用在更新或者删除方法上

| 属性/方法名      | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| value            | 缓存名，必填，它指定了你的缓存存放在哪块命名空间             |
| cacheNames       | 与 value 差不多，二选一即可                                  |
| key              | 可选属性，可以使用 SpEL 标签自定义缓存的key                  |
| allEntries       | 是否清空所有缓存，默认为  false。如果指定为 true，则方法调用后将立即清空所有的缓存 |
| beforeInvocation | 是否在方法执行前就清空，默认为  false。如果指定为 true，则在方法执行前就会清空缓存 |



# 图片base64编码

图片的base64编码就是可以将一张图片数据编码成一串字符串，使用该字符串代替图像地址url

在前端页面中常见的base64图片的引入方式：

```html
<img src="data:image/png;base64, iVBORw0.."/>
<!-- iVBORw0..是编码后的图片 -->
```

1. 优点

（1）base64格式的图片是文本格式，占用内存小，转换后的大小比例大概为1/3，降低了资源服务器的消耗；

（2）网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。

2. 缺点

（1）base64格式的文本内容较多，存储在数据库中增大了数据库服务器的压力；

（2）网页加载图片虽然不用访问服务器了，但因为base64格式的内容太多，所以加载网页的速度会降低，可能会影响用户的体验。

说明：医院logo图片小，因此上传医院logo是可以使用base64格式保存

> 图片转换为base64字符串时，该字符串中包含大量的加号“+”，服务器在解析数据时会把加号当成连接符，转换为空格，因此我们要做一下特殊处理
>
> 因此使用数据的时候，需要将其转换回去





# 跨域问题

`No 'Access-Control-Allow-Origin'`

### 概念

出于浏览器的同源策略限制。

**同源策略**会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）

**跨域问题**，三个地方，任何一个不相同都会产生跨域，不能访问

- 访问协议：http 访问 https
- 访问地址：192.128.1.1 访问 172.11.1.1
- 访问端口：9528 访问 8201

### 解决方式

1、返回新的CorsFilter（全局跨域）

2、重写 WebMvcConfigurer（全局跨域）

3、**使用注解 @CrossOrigin**（在Controller类或方法上）（局部跨域）

4、手动设置响应头 (HttpServletResponse)（局部跨域）

5、自定web filter 实现跨域



> - 上面前两种方式属于全局 CORS 配置，后两种属于局部 CORS配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过 @CrossOrigin 注解来进行细粒度更高的跨域资源控制。
> - 其实无论哪种方案，最终目的都是**修改响应头**，向响应头中添加浏览器所要求的数据，进而实现跨域



### 具体实现

#### 1、返回新的 CorsFilter(全局跨域)

在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。

```java
@Configuration
public class GlobalCorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        //1. 添加 CORS配置信息
        CorsConfiguration config = new CorsConfiguration();
        //放行哪些原始域
        config.addAllowedOrigin("*");
        //是否发送 Cookie
        config.setAllowCredentials(true);
        //放行哪些请求方式
        config.addAllowedMethod("*");
        //放行哪些原始请求头部信息
        config.addAllowedHeader("*");
        //暴露哪些头部信息
        config.addExposedHeader("*");
        //2. 添加映射路径
        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();
        corsConfigurationSource.registerCorsConfiguration("/**",config);
        //3. 返回新的CorsFilter
        return new CorsFilter(corsConfigurationSource);
    }
}
```



#### 2、重写 WebMvcConfigurer(全局跨域)

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                //是否发送Cookie
                .allowCredentials(true)
                //放行哪些原始域
                .allowedOrigins("*")
                .allowedMethods(new String[]{"GET", "POST", "PUT", "DELETE"})
                .allowedHeaders("*")
                .exposedHeaders("*");
    }
}
```



#### 3、使用注解 (局部跨域)

在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。

```java
@RestController
@CrossOrigin(origins = "*")
public class HelloController {
    @RequestMapping("/hello")
    public String hello() {
        return "hello world";
    }
}
```

在方法上使用注解 @CrossOrigin:

```java
@RequestMapping("/hello")
@CrossOrigin(origins = "*")
//@CrossOrigin(value = "http://localhost:8081") //指定具体ip允许跨域
public String hello() {
    return "hello world";
}
```



#### 4、手动设置响应头(局部跨域)

使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。

```java
@RequestMapping("/index")
public String index(HttpServletResponse response) {
    response.addHeader("Access-Allow-Control-Origin","*");
    return "index";
}
```



#### 5、使用自定义filter实现跨域

首先编写一个过滤器，可以起名字为MyCorsFilter.java

```java
@Component
public class MyCorsFilter implements Filter {
  public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletResponse response = (HttpServletResponse) res;
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
    response.setHeader("Access-Control-Max-Age", "3600");
    response.setHeader("Access-Control-Allow-Headers", "x-requested-with,content-type");
    chain.doFilter(req, res);
  }
  public void init(FilterConfig filterConfig) {}
  public void destroy() {}
}
```

在web.xml中配置这个过滤器，使其生效

```xml
<!-- 跨域访问 START-->
<filter>
 <filter-name>CorsFilter</filter-name>
 <filter-class>com.mesnac.aop.MyCorsFilter</filter-class>
</filter>
<filter-mapping>
 <filter-name>CorsFilter</filter-name>
 <url-pattern>/*</url-pattern>
</filter-mapping>
<!-- 跨域访问 END  -->
```



# 注册中心与服务调用（Nacos）

跨模块调用接口

例如，通过 service-hosp 远程调用 service-cmn 模块中的方法

实际开发中，是在不同的电脑上，需要远程调用才能解决

## 概念

注册中心就相当于调用者与被调用者之间的桥梁

## 常见的注册中心

1、Eureka（原生，2.0遇到瓶颈，停止维护）

2、Zookeeper（支持，专业的独立产品。例如：dubbo）

3、Consul（原生，GO语言开发）

4、Nacos

相对于 Spring Cloud Eureka 来说，Nacos 更强大。

Nacos = Spring Cloud Eureka + Spring Cloud Config

Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。



## 结构图

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205062138770.png" alt="image-20220506213853324" style="zoom:50%;" />

## 使用

进入解压目录`sh startup.sh -m standalone`（单机模式启动）

访问：http://localhost:8848/nacos

用户名密码：nacos/nacos

- 引入依赖
- 项目的配置文件中添加nacos服务地址

```properties
# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

- 项目的启动类上添加注解`@EnableDiscoveryClient`
