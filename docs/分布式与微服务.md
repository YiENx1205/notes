# 分布式系统的CAP原理

### CAP原理

- Consistency (一致性)

- Availability (可用性)

- Partition tolerance (分区容错性)

由于硬件条件，一个分布式系统必须保证分区容错性，要么CP要么AP，三者不可同时获得。

**一致性**(C)：一个分布式系统中各个节点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的

**可用性**(A)：负载过大后，集群整体是否还能响应客户端的读写请求。(服务对外要保证可用，而且是正常响应时间)

**分区容错性**(P)：分区容错性，就是高可用性，一个节点崩了，并不影响其它的节点(100个节点，挂了几个，不影响服务，越多机器越好)

### CA 满足的情况下，P不能满足的原因

数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足

### CP 满足的情况下，A不能满足的原因

数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足

### AP 满足的情况下，C不能满足的原因

机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足

### 注册中心选择的原则

Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或 者半数以上节点不可用，则无法提供服务，因此可用性没法满足

Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化

分布式系统中P肯定要满足，所以我们只能在一致性和可用性之间进行权衡 

- 如果要求一致性，则选择zookeeper，如金融行业 

- 如果要求可用性，则Eureka，如教育、电商系统 

没有最好的选择，最好的选择是根据业务场景来进行架构设计

# BASE理论

由于不能同时满⾜CAP，所以出现了BASE理论： 

1. BA：Basically Available，表示基本可⽤，表示可以允许⼀定程度的不可⽤，⽐如由于系统故障， 请求时间变⻓，或者由于系统故障导致部分⾮核⼼功能不可⽤，都是允许的 
2. S：Soft state：表示分布式系统可以处于⼀种中间状态，⽐如数据正在同步 
3. E：Eventually consistent，表示最终⼀致性，不要求分布式系统数据实时达到⼀致，允许在经过⼀ 段时间后再达到⼀致，在达到⼀致过程中，系统也是可⽤的

# 什么是RPC

RPC (Remote Procedure Call)，表示远程过程调⽤，对于Java这种⾯试对象语⾔，也可以理解为远程⽅法调⽤。

RPC 调⽤和 HTTP 调⽤是有区别的，RPC 表示的是⼀种调⽤远程⽅法的⽅式，可以使⽤HTTP协议、或直接基于 TCP 协议来实现 RPC。

在 Java 中，我们可以通过直接使⽤某个服务接⼝的代理对象来执⾏⽅法，⽽底层则通 过构造HTTP请求来调⽤远端的⽅法，所以，有⼀种说法是RPC协议是HTTP协议之上的⼀种协议，也是 可以理解的。

# SpringCloud组件

Spring Cloud 在接口调用上，大致会经过如下几个组件配合:

调用者（消费者）—>

`接口化请求调用 —> Feign —> Hystrix —> Ribbon —> Http Client(apache http components 或者 Okhttp) `

—>被调用者（生产者）

(1)**接口化请求调用**：当调用被@FeignClient注解修饰的接口时，在框架内部，将请求转换成Feign的请求 实例feign.Request，交由Feign框架处理。

(2)**Feign** :转化请求Feign是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，封装了Http调用流程。

(3)**Hystrix熔断器**:熔断处理机制 Feign的调用关系，会被Hystrix代理拦截，对每一个Feign调用请 求，Hystrix都会将其包装成HystrixCommand,参与Hystrix的流控和熔断规则。如果请求判断需要熔断， 则Hystrix直接熔断，抛出异常或者使用FallbackFactory返回熔断 Fallback 结果;如果通过，则将调用请求传递给Ribbon组件。

(4)**Ribbon负载均衡**:服务地址选择，当请求传递到Ribbon之后,Ribbon会根据自身维护的服务列表，根据服务的服务质量，如平均响应时间，Load等，结合特定的规则，从列表中挑选合适的服务实例，选择好机器之后，然后将机器实例的信息请求传递给Http Client客户端，HttpClient客户端来执行真正的Http接口调用;

(5)**HttpClient** :Http客户端，真正执行Http调用根据上层Ribbon传递过来的请求，已经指定了服务地址，则HttpClient开始执行真正的Http请求



# 注册中心与服务调用（Nacos）

跨模块调用接口

**例如，通过 service-hosp 远程调用 service-cmn 模块中的方法**

> hosp 中需要查找医院的等级，但是等级信息是存在数据字典中的，所以需要调用 cmn 中的方法，此时就需要使用 Nacos

实际开发中，是在不同的电脑上，需要远程调用才能解决

## 概念

注册中心就相当于调用者与被调用者之间的桥梁

### 客户端注册



### 第三方注册



## 常见的注册中心

1、Eureka（原生，2.0遇到瓶颈，停止维护）

2、Zookeeper（支持，专业的独立产品。例如：dubbo）

3、Consul（原生，GO语言开发）

4、Nacos

Nacos = Spring Cloud Eureka注册中心 + Spring Cloud Config配置中心 + Spring Cloud Bus消息总线

Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。

- 通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-discovery 实现服务的注册与发现。



## 结构图

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205062138770.png" alt="image-20220506213853324" style="zoom:50%;" />

## 使用

进入解压目录`sh startup.sh -m standalone`（单机模式启动）

访问：http://localhost:8848/nacos

用户名/密码：nacos/nacos

- 引入依赖
- 项目的配置文件中添加nacos服务地址

```properties
# nacos 服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
```

- 项目的启动类上添加注解`@EnableDiscoveryClient`

## 配置中心

将微服务共同的配置文件中的配置配置到nacos，这样修改可以只修改nacos

主要是集群的时候使用

### 使用

1、新建配置

a)Data ID 的完整规则格式如下

```
${prefix}-${spring.profiles.active}.${file-extension}
eg:service-statistics-dev.properties
```

- prefix 服务名称

- spring.profiles.active=dev 即为当前环境对应的 profile。 注意:当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，Data Id 的拼接格式变成 `${prefix}.${file-extension}`

- file-exetension 配置文件类型

2、引入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

3、创建**bootstrap.properties**配置文件

```properties
# 配置中心地址 
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
#spring.profiles.active=dev
# 该配置影响统一配置中心中的dataId 
spring.application.name=service-statistics
```

4、把项目之前的**application.properties**内容注释

### Note：spring boot 配置文件的加载顺序

**bootstrap.yml** (bootstrap.properties) **先加载** 

- bootstrap.yml 用于应用程序上下文的引导阶段。

- bootstrap.yml 由父Spring ApplicationContext加载。 

- 父ApplicationContext 被加载到使用 application.yml 的之前。
- 定义系统级别的参数

**application.yml** (application.properties) **后加载** 

- 如果application里写了`spring.profiles.active=dev`，还回去加载application-dev.properties
- 其中定义应用级别的配置

### 加载命名空间

dev、test、prod

```properties
spring.cloud.nacos.config.namespace=13b5c197-de5b-47e7-9903-ec0538c9db01
```



### 加载多个配置文件

一个配置文件分成多个，分到不同的配置文件中

```properties
spring.cloud.nacos.config.ext-config[0].data-id=redis.properties 
# 开启动态刷新配置，否则配置文件修改，工程无法感知 
spring.cloud.nacos.config.ext-config[0].refresh=true 
spring.cloud.nacos.config.ext-config[1].data-id=jdbc.properties 
spring.cloud.nacos.config.ext-config[1].refresh=true
```



## Feign服务调用

SpringCloud 中的组件，进行调用接口

引入依赖，见 service_client 模块

创建被调用的接口

```java
/**
 * 数据字典API接口
 */
// 这里的名称是nacos配置的时候配置的名称
// 被调用
@FeignClient("service-cmn")
@Repository
public interface DictFeignClient {

    /**
     * 获取数据字典名称
     * 将需要调用的方法直接复制过来
     * 将路径补充完整
     * PathVariable后指定名称,必须要写
     */
    @GetMapping("/admin/cmn/dict/getName/{value}")
    public String getName(@PathVariable("value") String value);

    /**
     * 获取数据字典名称
     */
    @GetMapping("/admin/cmn/dict/getName/{dictCode}/{value}")
    public String getName(@PathVariable("dictCode") String dictCode, @PathVariable("value") String value);
}
```

在调用端 hosp 中导入cmn-client 的依赖



## 报错

`Consider defining a bean of type 'com.yienx.yygh.cmn.client.DictFeignClient' in your configuration.`

- service中的依赖未打开
- 调用端hosp启动类上加注解`@EnableFeignClients(basePackages = "com.yienx")`，该注解根据服务名去找调用的服务
	- 扫描包：如果调用的是在同一个项目中没关系，但是在不同项目中不扫描包可能会找不到

`Did you forget to include spring-cloud-starter-loadbalancer`

springboot 和 springcloud 的版本过高引起的问题

```xml
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-loadbalancer</artifactId>
</dependency>
```







# 服务网关

## 概念

API网关出现的原因是微服务架构的出现，不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：

（1）客户端会多次请求不同的微服务，增加了客户端的复杂性。

（2）存在跨域请求，在一定场景下处理相对复杂。

（3）认证复杂，每个服务都需要独立认证。

（4）难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施。

（5）某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难。

以上这些问题可以借助 API 网关解决。API 网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过API 网关这一层。也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 API 网关来做，这样既提高业务灵活性又不缺安全性

## Spring Cloud Gateway

Spring Cloud Gateway旨在为微服务架构提供简单、有效和统一的API路由管理方式，Spring Cloud Gateway作为Spring Cloud生态系统中的网关，目标是替代Netflix Zuul，其不仅提供统一的路由方式，并且还基于Filer链的方式提供了网关基本的功能，例如：安全、监控/埋点、限流等

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205211159827.png" alt="未命名文件" style="zoom:67%;" />

## 步骤：搭建server-gateway模块

### 1、配置pom.xml

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>

    <!-- 服务注册 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    
    <!-- 依赖中加上loadbalancer -->
    <!-- 高版本boot不加可能会导致503 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    </dependency>
</dependencies>

```

### 2、在resources下添加配置文件

```properties
# 服务端口
server.port=80
# 服务名
spring.application.name=service-gateway

# nacos服务地址
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

#使用服务发现路由
spring.cloud.gateway.discovery.locator.enabled=true

#设置路由id
spring.cloud.gateway.routes[0].id=service-hosp
#设置路由的uri;
#lb:load balance的缩写，负载均衡，直接去nacos中找服务
spring.cloud.gateway.routes[0].uri=lb://service-hosp
#设置路由断言,代理servicerId为auth-service的/auth/路径
spring.cloud.gateway.routes[0].predicates= Path=/*/hosp/**

#设置路由id
spring.cloud.gateway.routes[1].id=service-cmn
#设置路由的uri
spring.cloud.gateway.routes[1].uri=lb://service-cmn
#设置路由断言,代理servicerId为auth-service的/auth/路径
spring.cloud.gateway.routes[1].predicates= Path=/*/cmn/**

```



### 3、添加启动类

```java
package com.yienx.yygh;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ServerGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServerGatewayApplication.class, args);
    }
}

```



### 4、全局跨域解决(Gateway里)

```java
// 这个是reactive包的
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

@Configuration
public class CorsConfig {
    @Bean
    public CorsWebFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedMethod("*");
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");

        UrlBasedCorsConfigurationSource source = 
            new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}
// @CrossOrigin都去掉
```



### 报错

使用gateway后前端503

```properties
#发现是lb找不到，版本依赖的问题，改成端口就好了
#spring.cloud.gateway.routes[0].uri=lb://service-hosp
spring.cloud.gateway.routes[0].uri=http://localhost:8201
```

或者

```xml
<!-- 依赖中加上loadbalancer -->
<!-- 没找到依赖导致的 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

# Hystrix熔断器

Hystrix 是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。

比如系统中有很多服务，当某些服务不稳定的时候，使用这些服务的用户线程将会阻塞，如果没有隔离 机制，系统随时就有可能会挂掉，从而带来很大的风险。SpringCloud使用Hystrix 组件提供断路器、资源 隔离与自我修复功能。下图表示服务B触发了断路器，阻止了级联失败

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202206012125840.png" alt="image-20220601212514606" style="zoom:50%;" />



## 使用

**消费端**

- 引入依赖（openFeign中就有）

- 配置文件

```properties
#开启熔断机制
feign.hystrix.enabled=true
# 设置hystrix超时时间，默认1000ms 
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=6000

```

- 消费端的client包中创建熔断器的实现类

```java
@Component
public class VodFileDegradeFeignClient implements VodClient {
    @Override
    public R removeVideo(String videoId) {
        return R.error().message("time out");
	}
	@Override
    public R removeVideoList(List videoIdList) {
        return R.error().message("time out");
	} 
}
```



**Client 上**

- 修改注解

```java
@FeignClient(name = "service-vod", 
             fallback = VodFileDegradeFeignClient.class)
@Component
public interface VodClient {
    @DeleteMapping(value = "/eduvod/vod/{videoId}")
    public R removeVideo(@PathVariable("videoId") String videoId);
    @DeleteMapping(value = "/eduvod/vod/delete-batch")
    public R removeVideoList(@RequestParam("videoIdList") List videoIdList);
}
```



