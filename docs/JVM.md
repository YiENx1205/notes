# 面试题目

## 1、int a = 1 存放在哪？

- a作为类的成员变量，存放于方法区中；1保存在堆(Heap)的实例中

- a作为方法局部变量，存放于Java虚拟机栈(JVM Stacks)的局部变量表中；1也保存在栈内存中。



# Java源程序编译运行过程

Java 源文件 → 编译器 → 字节码文件 .class → JVM →机器码

> 字节码文件
>
> - 不专对特定机器，无需重新编译就可以在不同的机器上运行
> - 以一个字节 8bit 为最小单位储存

# JVM运行机制

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203311549622.png" alt="第02章_JVM架构-简图" style="zoom:33%;" />

**线程**

- 线程时进程中执行运算（资源分配）的最小单位，是进程的一个实体

**执行引擎**

- 将字节码指令解释/编译为对应平台上的本地机器指令

# JVM内存区域

> 栈管运行，堆管存储

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301347028.png" alt="image-20220330134754626" style="zoom:40%;" />

**线程私有区**【程序计数器、虚拟机栈（Java栈）、本地方法栈】

- 生命周期与线程相同, 依赖用户线程的启动/结束，而创建/销毁在 Hotspot VM 内

**线程共享区**【Java堆（堆空间）、方法区】

- 随虚拟机的启动/关闭而创建/销毁

**直接内存**【不受 JVM GC 管理】

- 不是 JVM 运行时数据区的一部分，但 I/O 可以使用 Native 函数直接分配堆外内存
- 直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。 配置虚拟机参数时，不要忽略直接内存防止出现 OutOfMemoryError 异常。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301115606.png" alt="image-20220330111510231" style="zoom: 33%;" />

<br>

## 一、程序计数器 PC寄存器

- 当前线程所执行的字节码的行号（地址）指示器，方便时间片结束后再次回来可以继续执行
- 唯一一个没有规定 OOM（OutOfMemoryError）的区域

<br>

## 二、虚拟机栈（Java栈）

> 存放`局部变量`
>
> - 8种基本数据类型
>
> - 引用数据类型的`引用`

异常：StackOverflow；OOM

栈帧弹出：函数返回或抛出异常

### 1、总体结构

描述java方法执行的内存模型，每个方法在执行的时候都会创建一个栈帧（Stack Frame）

参与方法的调用与返回

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301118092.png" alt="image-20220330111823493" style="zoom: 33%;" />

#### 2、栈帧

- 栈中`存储数据的基本单位`，一个栈帧对应一个方法

#### 栈帧存储的数据

方法在本次执行过程中所用到的局部变量、动态链接、方法出口等信息。栈帧中主要保存3 类数据：

- 本地变量（Local Variables）：输入参数和输出参数以及方法内的变量，**局部变量**。
- 栈操作（Operand Stack）：记录出栈、入栈的操作。
- 栈帧数据（Frame Data）：包括类文件、方法等等。

#### 结构

- **局部变量表**：定义为一个数字数组，存储方法参数和方法体内声明的`局部变量`
	- 其大小是编译期确定下来的
	- 8种基本数据类型、引用类型的引用（reference）、returnAdress类型
	- 都是数
- **操作数栈**（表达式栈）：保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- **动态链接**（指向运行时常量池中方法的引用）
	- 字节码文件中，所有变量和方法引用都作为符号引用保存在class常量池中
	- 动态链接就是为了将这些符号引用转换为调用方法的直接引用
- **方法返回地址**（方法正常退出或者异常退出的定义）
- 一些附加信息：例如对程序调试提供支持的信息

### 3、面试题

1. 举例栈溢出的情况 StackOverflowError

	- 大量递归
	- 过多的全局变量
	- 数组、List、map数据是否过大

	- 通过-Xss设置栈的大小；OOM

2. **内存溢出的情况OOM**

	- 内存溢出是由于没被引用的对象（垃圾）过多造成JVM没有及时回收，造成的内存溢出。
	- 是否应用中的类中和引用变量过多使用了Static修饰 如public staitc Student s；
	- 是否应用中使用了大量的递归（递归中有新建对象）
	- 检查是否有数组，List，Map中存放的是对象的引用而不是对象，因为这些引用会让对应的对象不能被释放
	- 检查是否使用了“非字面量字符串进行 + ”的操作。因为 String 类的内容是不可变的，每次运行 " + " 就会产生新的对象，如果过多会造成新 String 对象过多，从而导致 JVM 没有及时回收而出现内存溢出。

	```java
	String s1 = "My name";
	String s2 = "is";
	String s3 = "xuwei";
	String str = s1 + s2 + s3 +.........;
	// 这是会容易造成内存溢出的
	
	String str =  "My name" + " is " + " xuwei" 
	    + " nice " + " to " + " meet you"; 
	// 但是这种就不会造成内存溢出。
	// 因为这是”字面量字符串“，在运行"+"时就会在编译期间运行好。
	// 不会按照JVM来执行的。
	```

	

3. 调整栈的大小，就能保证不出现溢出吗？不能

4. 分配的栈内存越大越好吗？不是

5. 垃圾回收会涉及虚拟机栈吗？不会

6. 方法中定义的局部变量是否线程安全？

	- 一个线程安全，多个线程且不考虑同步问题会存在安全问题

<br>

## 三、本地方法栈

>虚拟机栈为 Java 方法服务，而本地方法栈为 Native 方法服务。

`HotSpot VM 将本地方法栈和虚拟机栈合二为一`

<br>

## 四、堆

> **TIP**：**new 的都在堆中**
>
> 创建的`实例对象实体`和`数组`都保存在堆中，也是 GC 的重要区域
>
> NOTE：静态引用对应的`对象实体`也始终都在堆中
>
> 数组也是new出来的

1.8后加上`字符串池`和`静态变量（引用名）`

所有线程共享 Java 堆，但是还可以划分`线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）`

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301316327.png" alt="image-20220330131644568" style="zoom:40%;" />

> 分代是为了**优化GC性能**
>
> - 不同对象生命周期不同
> - Eden区主要是生命周期很短的对象，经常GC
> - 老年代主要是生命周期很长的对象，不经常GC
> 	- 例如：IOC容器对象、线程池对象、数据库连接池对象等等
> - 幸存者区作为二者之间的过渡地带



### 1、新生代young

- **Eden**：Java 新对象的出生地
	- `如果新创建的对象占用内存很大，则直接分配到老年代`
	- 当 Eden 内存不够的时候会触发 MinorGC，对新生代区进行 GC
- **ServivorFrom**：上一次 GC 的幸存者，作为这一次 GC 的被扫描者
- **ServicorTo**：保留了一次 MinorGC 过程中的幸存者
	- to 和 from 不是固定的
- **MinorGC** 的过程（复制 -> 清空 -> 互换，复制算法）
	- eden、from 中存活的对象复制到 to，年龄 + 1
		- to 满了就直接进 old 
		- 年龄到了15，即进行了15次 GC，进 old
	- 清空 eden、from 中的对象
	- to 和 from 互换指针，即原 to 成为下一次 GC 的 from

> 复制必交换，谁空谁为 to
>
> QA：为什么有两个survivor区？复制算法，避免碎片化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203310942440.png" alt="image-20220331094237355" style="zoom:50%;" />

### 2、老年代old

old 中的对象比较稳定，Major GC 不会频繁执行

MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

> **TIP**
>
> Minor GC：清理 young
>
> Major GC：清理 old
>
> Full GC：清理整个堆空间
>
> 有时FGC和Major GC说的是一个

<br>

### 3、TLAB（Thread Local Allocation Buffer，TLAB）

线程私有缓存区，在Eden区分配（`1%`），但其他线程也可以访问，只是不需要加锁了，也可以避免了线程安全问题

JVM 将 TLAB 作为内存分配的首选

<br>

### 4、堆是分配对象存储的唯一选择吗？不是

如果经过`逃逸分析（Escape Analysis）`后发现，一个对象并没有逃溢出方法的话，那么就可能被优化成栈上分配。

逃逸分析：

- 一个对象在方法中被定义后，只在方法内部使用，则认为没有逃逸
- 一个对象在方法中被定义后，被外部方法所引用，则认为发生逃逸
	- 如作为调用参数传递到其他地方
	- `成员变量赋值`、`方法返回值`、`实例引用传递`

>快速判断是否发生了逃逸，看 new 的**对象实体**是否有可能在方法外被调用
>
>开发中能使用局部变量的，就不要使用在方法为定义。

### 5、逃逸分析之代码优化

栈上分配

同步省略

标量替换/分离对象

<br>

## 五、方法区

### 1、存放内容

- 类(型)信息：类class、枚举enum、接口interface、注解annotation
	- 类型的全名：包名.类名
	- 父类的完整有效名
	- 修饰符
	- 直接接口的一个有序列表
- 域(Field)信息、方法信息
- 静态变量/类变量（`引用名`）：non-final的类变量（`1.7及之后被移入堆`）
- 运行时常量池（`其中的字符串常量池StringTable在1.7及之后移入了堆`）
- 即时编译器编译后的代码缓存

> **TIP**：全局常量 static final
>
> 全局常量在编译时就会被分配

### 2、概念

- 标准层面：方法区（Method Area）
- 具体实现层面：
	- ≤1.7 永久代（PermGen）：名义上属于堆，实现上不属于堆
		- 1.7 中就已经将`字符串常量池StringTable和静态变量移入堆中`了
	- ≥1.8 元空间（MetaSpace）
		- 元空间使用本地内存
		- 类的元数据（描述代码间关系联系的数据）存入 native memory

<br>

### 3、永久代为什么被元空间替换？

1. 为永久代设置空间大小是很难确定的
2. 堆永久代进行调优很困难

### 4、StringTable为什么调整

永久代回收效率低，在FGC的时候才会触发，会导致StringTable回收效率不高，而开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。当到堆中，能及时回收内存。

### 5、方法区的垃圾回收

主要针对两部分

- 常量池中废弃的常量
- 不再使用的类型

永久代也是会有垃圾回收的

<br>

## Java栈、堆和方法区的关系

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301255028.png" alt="image-20220330125507742" style="zoom: 33%;" />

```java
Person person = new Person();
/*
	Person 方法区 .class，类型信息
	person 局部变量：Java栈；实例变量：Java堆中
	new Person() Java堆
*/

class Test {
    static Person staticPer = new Person();
    Person instancePer = new Person();
    void foo() {
        Person localPer = new Person();
    }
}
/*
	new Person()	无论什么情况始终都在堆中
	staticPer		静态变量：≤1.6方法区，≥1.7堆
	instancePer		实例变量：随着Test的对象实例存在堆
	localPer		局部变量：存在foo()方法栈帧的局部变量表
*/
```



<br>

# JVM类加载机制

加载、验证、准备、解析、初始化

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301024818.png" alt="image-20220330102400457" style="zoom:67%;" />

1. 加载

	- 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口

2. 验证

	- 确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求

3. 准备

	- 在方法区中分配这些变量所使用的内存空间

	```java
	public static int i = 8080;
	// 变量在准备阶段的默认值为0，在编译（初始化）阶段才会显式赋值8080
	public static final int i =8080;
	// final在准备阶段就会赋值
	```

4. 解析

	- 虚拟机将常量池中的符号引用替换为直接引用的过程
		- 符号引用：引用的目标不一定要加载在内存中
		- 直接引用：引用的目标必定已经在内存中了

5. 初始化

	TIP：不会执行初始化的情况

	- 通过子类引用父类的静态字段，只会触发父类的初始化
	- 定义对象数组
	- 通过类名获取 Class 对象
	- 通过 Class.forName 加载指定类时，指定参数 initialize = false
	- 通过 ClassLoader 默认的 loadClass 方法


## 类加载
**启动类加载器 Bootstrap ClassLoader**

- 加载 **$JAVA_HOME/jre/lib** 下的 jar 包，如 rt.jar

**扩展累加载器 Extension ClassLoader**

- 加载\$JAVA_HOME/jre/lib/*.jar 、-Djava.ext.dirs 参数指定目录下的 jar 包、**$JAVA_HOME/jre/lib/ext/classes** 目录下的 class

**应用程序类加载器 Application ClassLoader**

- 加载用户路径 classpath 中指定的 jar 包及目录中的 class

- 自定义类加载器：程序员自己开发一个类继承 java.lang.ClassLoader， 定制类加载方式
	- 加载用户指定目录下的，挂载应用类加载器

### 双亲委派机制

- 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求**委派给父类**去完成，
- 每一个层次类加载器都是如此，因此所有的加载请求都应该传送到**启动类加载器**中，
- 只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202203301035804.png" alt="image-20220330103519857" />

> **TIP**
>
> - **避免类的重复加载**：父加载器加载了一个类，就不必让子加载器再去查找了。同时也保证了在整个 JVM 范围内全类名是类的唯一标识。
> 	- 比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。
> - **安全机制**：避免恶意替换 JRE 定义的核心 API
> 	- 比如自定义一个 java.lang.String 类，最终加载的还是启动类加载器加载的String



<br>

# 垃圾回收机制

作用区域：方法区和堆，重点是堆

从次数上

- 频繁收集Young区
- 较少收集Old区
- 基本不动Perm区

## 一、标记阶段：如何判断对象死亡

### 1、引用计数法

记录对象被引用的情况

引用一次计数+1，解除引用-1；

可能会循环引用，导致计数器无法归零

### 2、可达性分析、根搜索法 GC Roots

`解决循环引用的问题，防止内存泄漏`

核心原理：判断一个对象，是否存在从『堆外』到『堆内』的引用。

以`根对象集合（GC Roots）`为起点，从上至下的方式搜索被根对象集合所连接的目标对象是否可达。搜索的路径称为`引用链（Reference Chain）`

- 如果在 GC Roots 和一个对象之间没有可达路径，则称该对象不可达
- 不可达对象经过至少两次标记后，如果仍是可回收对象，则将面临回收

**GC Roots 包括**：

- Java栈中局部变量、各个线程被调用方法中使用的参数
- 本地方法栈中局部变量
- 方法区中
	- 类引用类型静态变量/类变量
	- 常量引用的对象，字符串常量池里的引用
- 被synchronized持有的对象
- 基本数据类型对应的Class对象，常驻异常对象、系统类加载器

根据选择的GC收集器和当前回收的内存区域不同，还可以有其他对象“临时性”加入，比如：分代收集和局部回收

> **TIP**
>
> Root 采用栈方式存放变量和指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root

由于枚举根节点需要停顿，所以GC进行时必须Stop The World (STW，暂停所有线程)

## 对象的finalization机制

Java语言提供了对象终止（finalization）机制来允许开发人员提供`对象被销毁之前的自定义处理逻辑`

**垃圾回收对象之前，总会先调用这个对象的finalize()方法**

finalize允许在子类中被重写，用于在对象回收时进行资源释放，比如：关闭文件、套接字、数据库连接等

**不要主动调用finalize，应交给垃圾回收**，因为

- 在finalize时可能会导致对象复活
- finalize的执行时间没有保障，完全由GC线程决定，极端下，若不GC，则finalize不会执行
- 一个糟糕的finalize会严重影响GC性能

### JVM中对象的三种状态

- 可触及的：可达
- 可复活的：不可达，但是对象可能在finalize中复活
- 不可触及的：没复活；不可触及的对象不可能被复活，因为`finalize只会被调用一次`

### GC Roots中的两次标记

1. 没有引用链，第一次标记
2. 判断是否有必要执行finalize
	- 没有重写finalize、或finalize已经被调用过了，则对象不可触及
	- 重写了finalize且也没调过，JVM会创建一个低优先级的Finalizer线程触发finalize方法
	- 若finalize中建立了联系，但是之后再次断开引用链，finalize不会再触发

## 二、清除阶段：垃圾回收算法

> **清除**
>
> 不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放

### 1、标记-清除（Mark-Sweep）

**标记**：从根节点开始遍历，标记所有被引用的对象（可达对象）

**清除**：对堆内存从头到尾进行线性遍历，回收没有标记的对象

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011000580.png" alt="第14章_标记-清除算法" style="zoom:33%;" />

**缺点**

- 效率不算高
- 清理出来的空间内存不连续，`内存碎片化严重`，后续可能发生大对象找不到可用空间
- 需要维护一个空闲列表

### 2、复制（Copying）

为了解决标记清除的内存碎片化的缺陷提出

将**内存空间分为两块**，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存大角色，完成垃圾回收

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011015298.png" alt="第14章_复制算法" style="zoom:33%;" />

**优点**

- 实现简单，运行搞笑
- 空间连续，不会碎片

**缺点**

- 需要两倍大空间
- 存活对象多多话，效率会低

**特别的**

特别适合垃圾对象很多，存活对象很少的场景，例如：Young区的survior0和survior1

### 3、标记-压缩/整理（Mark-Compact）

结合以上两种算法，避免缺陷

标记后将存活对象移向内存的一端，按序排放，然后清除端边界外的对象

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204011022855.png" alt="第14章_标记-压缩算法" style="zoom:33%;" />

**缺点**

- 效率低于复制算法
- 移动对象时，如果对象被其他对象引用，则还需要调整引用的地址
- 移动过程中，需要全程暂停用户应用程序

### 分代收集

根据不同分代区域，选择合适的算法

- 新生代：生命周期短，存活对象少
	- 使用复制算法，所以存在from和to区
- 老年代：区域大，生命周期长，回收频率不高
	- 使用标记清除和标记压缩的混合实现
		- Mark阶段的开销与存活对象的数量成正比
		- Sweep阶段的开销与所管理区域的大小成正比
		- Compact阶段的开销与存活对象的数据成正比

### 分区收集

将整个堆空间划分为连续的不同小区间region，每个小区间独立使用，独立回收，可以控制一次回收多少个小区间

### 增量收集

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿（STW），那么就可以`让垃圾收集线程和应用程序线程交替执行`。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过`对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。`

**缺点**：交替执行，系统吞吐量下降

## 垃圾回收的相关概念

### 1、Systenm.gc()的理解

默认情况下，System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象的内存

### 2、内存溢出和内存泄露

### 3、Stop The World

### 4、垃圾回收的并行与并发

### 5、安全点与安全区域

### 6、Java的四类引用类型

## 三、垃圾回收器

