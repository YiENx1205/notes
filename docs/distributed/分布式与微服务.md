# 分布式系统的CAP原理

### CAP原理

- Consistency (一致性)

- Availability (可用性)

- Partition tolerance (分区容错性)

> 由于硬件条件，一个分布式系统必须保证分区容错性，要么CP要么AP，无法同时保证。

**一致性**(C)：一个分布式系统中各个节点之间能**及时的同步数据**，在数据同步过程中，是不能对外提供服务的

**可用性**(A)：负载过大后，集群整体是否还能响应客户端的读写请求。(服务对外要保证可用，而且是**正常响应时间**)

**分区容错性**(P)：分区容错性，就是高可用性，一个节点崩了，并不影响其它的节点(100个节点，挂了几个，不影响服务，越多机器越好)

### 不能同时满足的原因

#### CA 满足的情况下，P不能满足

数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足

#### CP 满足的情况下，A不能满足

数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足

#### AP 满足的情况下，C不能满足

机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足

### 注册中心选择的原则

Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足。

Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化

分布式系统中P肯定要满足，所以我们只能在一致性和可用性之间进行权衡 

- 如果要求一致性，则选择zookeeper，如金融行业 

- 如果要求可用性，则Eureka，如教育、电商系统 

没有最好的选择，最好的选择是根据业务场景来进行架构设计

# BASE理论

由于不能同时满⾜CAP，所以出现了BASE理论： 

1. BA：Basically Available，表示基本可⽤，表示可以允许⼀定程度的不可⽤，⽐如由于系统故障， 请求时间变⻓，或者由于系统故障导致部分⾮核⼼功能不可⽤，都是允许的 
2. S：Soft state：表示分布式系统可以处于⼀种中间状态，⽐如数据正在同步 
3. E：Eventually consistent，表示最终⼀致性，不要求分布式系统数据实时达到⼀致，允许在经过⼀ 段时间后再达到⼀致，在达到⼀致过程中，系统也是可⽤的

# 数据一致性模型

- **强一致性**：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP理论，这种实现需要牺牲可用性。
- **弱一致性**：系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后 可以读到。用户读到某一操作对系统数据的更新需要一段时间，称这段时间为“不一致性窗口”。
- **最终一致性**：最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时问的同步之后。最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。到达最终一致性的时间，就是不一致窗口时间；在没有故障发生的前提下，不一致窗口的时问主要受通信延迟，系统负载和复制副本的个数影响。最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性。

# 什么是RPC

RPC (Remote Procedure Call)，表示**远程过程调⽤**，对于Java这种⾯试对象语⾔，也可以理解为远程⽅法调⽤。

RPC 调⽤和 HTTP 调⽤是有区别的，RPC 表示的是⼀种调⽤远程⽅法的⽅式，可以使⽤HTTP协议、或直接基于 TCP 协议来实现 RPC。

在 Java 中，我们可以通过直接使⽤某个服务接⼝的代理对象来执⾏⽅法，⽽底层则通 过构造HTTP请求来调⽤远端的⽅法，所以，有⼀种说法是RPC协议是HTTP协议之上的⼀种协议，也是可以理解的。

HttpClient

# 什么是RMI

RMI (Remote Method Invocation) 模型是一种分布式对象应用，使用 RMI 技术可以使一个 JVM 中的对象，调用另一个 JVM 中的对象方法并获取调用结果。

可以理解为是java中用于实现RPC的一种机制，跨JVM调用对象

直接或间接实现接口 java.rmi.Remote 成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。

远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求

---



# 分布式ID

单体架构中可以使用数据库的主键，或者直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就可能会出现ID冲突。

1. UUID：复杂度最低，但是会影响存储空间和性能（因为无序）
2. 单机数据库的自增主键
3. redis、zookeeper的特性生成id，比如redis的自增命令、zookeeper的顺序节点

2. 雪花算法：趋势递增，因为不同机器时间可能不一致

# 分布式锁

单体架构中，多个线程属于同一个进程的，可以使用sychronized、ReentrantLock来作为锁。

但是分布式中需要一个分布式锁的生成器。

1. **zookeeper** ：利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是**CP**，所以由它实现的分布式锁**更可靠**，不会出现混乱
2. **redis**：利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是**高可用**，因为redis保证的是**AP**，所以由它实现的分布式锁可能不可靠，不稳定（一旦redis中的数据出现了不一致），可能会出现多个客户端同时加到锁的情况

# 分布式事务

在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于一次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。常用解决方案有：

1. 本地消息表：创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统
2. 消息队列：目前**RocketMQ中支持事务消息**，它的工作原理是：
	- 生产者订单系统先发送一条half消息到Broker， half消息对消费者而言是不可见的
	- 再创建订单，根据创建订单成功与否，向Broker发送commit或rolback
	- 并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功
	- 一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束
	- 如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理

# 分布式架构下，session共享方案

### 1、存入cookie（有风险）

### 2、服务器之间进行session同步

不过当服务器数量较多的时候，同步会有延迟甚至失败

### 3、使用redis存储

- 实现了session共享
- 可以水平扩展（增加redis服务器）
- 服务器重启，session不会丢失
- 可以跨平台（网页端和app端）

# 服务注册与发现

服务注册与发现是分为注册和发现两个关键的步骤。

**服务注册**：服务进程在注册中心注册自己的元数据信息。通常包括主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的信息。

**服务发现**：客户端服务进程向注册中心发起查询，来获取服务的信息。服务发现的一个重要作用就是提供给客户端一个可用的服务列表。

## 服务注册

服务注册有两种形式：客户端注册和代理注册。

**客户端注册**

客户端注册是服务自己要负责注册与注销的工作。当服务启动后注册线程向注册中心注册，当服务下线时注销自己。

<img src="./image/服务注册1.png" alt="20210504232139-2021-05-04-23-21-40" style="zoom: 67%;" >

这种方式的缺点是注册注销逻辑与服务的业务逻辑耦合在一起，如果服务使用不同语言开发，那需要适配多套服务注册逻辑。

**代理注册**

代理注册由一个单独的代理服务负责注册与注销。当服务提供者启动后以某种方式通知代理服务，然后代理服务负责向注册中心发起注册工作。

<img src="./image/服务注册2.png" alt="20210504232151-2021-05-04-23-21-52" style="zoom:67%;" >


这种方式的缺点是多引用了一个代理服务，并且代理服务要保持高可用状态。

## 服务发现

服务发现也分为客户端发现和代理发现。

**客户端发现**

客户端发现是指客户端负责向注册中心查询可用服务地址，获取到所有的可用实例地址列表后客户端根据负载均衡算法选择一个实例发起请求调用。

<img src="image/服务发现1.png" alt="20210504232203-2021-05-04-23-22-04" style="zoom:67%;" >

这种方式非常直接，客户端可以控制负载均衡算法。但是缺点也很明显，获取实例地址、负载均衡等逻辑与服务的业务逻辑耦合在一起，如果服务发现或者负载平衡有变化，那么所有的服务都要修改重新上线。

**代理发现**

代理发现是指新增一个路由服务负责服务发现获取可用的实例列表，服务消费者如果需要调用服务A的一个实例可以直接将请求发往路由服务，路由服务根据配置好的负载均衡算法从可用的实例列表中选择一个实例将请求转发过去即可，如果发现实例不可用，路由服务还可以自行重试，服务消费者完全不用感知。

<img src="image/服务发现2.png" alt="20210504232217-2021-05-04-23-22-17" style="zoom:67%;" >


## 心跳机制

如果服务有多个实例，其中一个实例出现宕机，注册中心是可以实时感知到，并且将该实例信息从列表中移出，也称为摘机。

如何实现摘机？业界比较常用的方式是通过心跳检测的方式实现，心跳检测有**主动**和**被动**两种方式。

**被动检测**是指服务主动向注册中心发送心跳消息，时间间隔可自定义，比如配置5秒发送一次，注册中心如果在三个周期内比如说15秒内没有收到实例的心跳消息，就会将该实例从列表中移除。

<img src="image/心跳机制.png" alt="20210504232235-2021-05-04-23-22-35" style="zoom:67%;" >

上图中服务A的实例2已经宕机不能主动给注册中心发送心跳消息，15秒之后注册就会将实例2移除掉。

**主动检测**是注册中心主动发起，每隔几秒中会给所有列表中的服务实例发送心跳检测消息，如果多个周期内未发送成功或未收到回复就会主动移除该实例。

<img src="image/心跳机制主动检测.png" alt="20210504232247-2021-05-04-23-22-48" style="zoom:67%;" >

# Zookeeper

分布式应用程序协调软件

## ZAB协议

ZAB协议是Zo0keeper用来实现一致性的原子广播协议，该协议描述了Zookeeper是如何实现一致性的，分为三个阶段：
1. 领导者选举阶段：从Zookeeper集群中选出一个节点作为Leader，所有的写请求都会由Leader节点来处理
2. 数据同步阶段：集群中所有节点中的数据要和Leader节点保持一致，如果不一致则要进行同步
3. 请求广播阶段：当Leader节点接收到写请求时，会利用两阶段提交来广播该写请求，使得写请求像事务一样在其他节点上执行，达到节点上的数据实时一致但值得注意的是，Zookeeper只是尽量的在达到强一致性，实际上仍然只是最终一致性的。

# 负载均衡算法

### 1、轮询法

将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

### 2、随机法

通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。

### 3、源地址哈希法

源地址哈希的思想是根据获取客户端的IP地址，通过**哈希函数**计算得到的一个数值用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要**访问服务器的序号**。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。

### 4、加权轮询法

不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请求；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

### 5、加权随机法

与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。

### 6、最小连接数法

最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。

# 服务雪崩？服务限流？

## 一、服务雪崩

当服务A调用服务B，服务B调用C，此时大量请求突然请求服务A，假如服务A本身能抗住这些请求，但是如果服务C抗不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。

C顶不住，导致B堆积，从而A不可用了。

## 二、服务限流

服务限流是指在高并发请求下，为了保护系统，可以**对访问服务的请求进行数量上的限制**，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。



# 服务熔断？服务降级？

## 一、服务熔断

当服务A调用的某个**服务B不可用时**，上游服务A为了保证自己不受影响，从而**不再调用服务B**，直接返回一个结果，减轻服务A和服务B的压力，直到服务B恢复。

## 二、服务降级

当发现系统压力过载时，可以通过关闭某个服务，或限流某个服务来**减轻系统压力**。服务水平下降。

## 三、异同

**同**：

1. 都是为了防止系统崩溃
2. 都让用户体验到某些功能暂时不可用

**异**：熔断是下游服务故障触发的，降级是为了降低系统负载。

# SOA和微服务

SOA（Service-Oriented Architecture，面向服务架构）和微服务都是分布式架构。

SOA：所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用。

微服务：将系统中的各个功能抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207132223010.png" alt="aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1iZGE0YWVlMDg1OTUwNjczN2ZmNGNmOWIxM2ZkN2UxY183MjB3LmpwZw"  />

# 接口幂等性的实现

### 概念

同一个接口，多次发出同一个请求，必须保证操作只执行一次。

调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

比如下面这些情况，如果没有实现接口幂等性会有很严重的后果：

- 支付接口，重复支付会导致多次扣钱

- 订单接口，同一个订单可能会多次创建。

### 实现方法

- **唯一id**：每次操作，都根据操作和内容生成唯一的id，在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或者redis等。

- **token机制**：服务端提供发送token的接口，业务调用接口前先获取token，然后调用业务接口请求时，把token携带过去，服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除

- **建去重表**：将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了版本控制。
- **增加版本号**：当版本号符合时，才能更新数据（乐观锁）

- **状态控制**：例如订单有状态已支付 末支付 支付中 支付失败，当处于未支付的时候才允许修改为支
	付中等
