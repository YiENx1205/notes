# 接口幂等性的实现

### 概念

同一个接口，多次发出同一个请求，必须保证操作只执行一次。

调用接口发生异常并且重复尝试时，总是会造成系统所无法承受的损失，所以必须阻止这种现象的发生。

比如下面这些情况，如果没有实现接口幂等性会有很严重的后果：

- 支付接口，重复支付会导致多次扣钱
- 订单接口，同一个订单可能会多次创建。

出现问题的情况：前端重复提交表单、恶意刷单、接口超时重复提交、消息重复消费

### 实现方法

#### 数据库唯一id

每次操作，都根据操作和内容生成唯一的id（分布式id），在执行之前先判断id是否存在，如果不存在则执行后续操作，并且保存到数据库或者redis等。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208030915838.png" alt="图片" style="zoom: 67%;" />

> 只适用于插入和删除操作。

#### token机制

服务端提供发送token的接口，业务调用接口前先获取token，服务端存储token进redis（k：token，v：业务信息）

然后调用业务接口请求时，把token（放到headers中）携带过去，服务器判断token是否存在redis中，存在表示第一次请求，可以继续执行业务，执行业务完成后，最后需要把redis中的token删除。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208030925108.png" alt="图片" style="zoom:67%;" />

> 注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作

#### 建去重表

将业务中有唯一标识的字段保存到去重表，如果表中存在，则表示已经处理过了版本控制。

#### 增加版本号(乐观锁)

只适用于更新操作，当版本号符合时，才能更新数据（乐观锁）

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208030930324.png" alt="图片" style="zoom:67%;" />

#### 状态控制

例如订单有状态已支付 末支付 支付中 支付失败，当处于未支付的时候才允许修改为支付中等

#### 下游传递唯一序列号

下游服务生成分布式 ID 作为序列号，然后执行请求调用上游接口，并附带“唯一序列号”与请求的“认证凭据ID”。

上游服务进行安全效验，检测下游传递的参数中是否存在“序列号”和“凭据ID”。

上游服务到 Redis 中检测是否存在对应的“序列号”与“认证ID”组成的 Key，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该“序列号”和“认证ID”组合作为 Key，以下游关键信息作为 Value，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202208030950257.png" alt="图片" style="zoom:67%;" />

### 总结

- 对于下单等存在唯一主键的，可以使用“唯一主键方案”的方式实现。
- 对于更新订单状态等相关的更新场景操作，使用“乐观锁方案”实现更为简单。
- 类似于前端重复提交、重复下单、没有唯一ID号的场景，可以通过 Token 与 Redis 配合的“防重 Token 方案”实现更为快捷。



[参考](https://mp.weixin.qq.com/s/qrmdU5ijy3P6SeP-MAVjJw)

