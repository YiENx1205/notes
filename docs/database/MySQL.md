## 1、事务

一个事务其实就是一个完整的业务逻辑，是一个最小的工作单元。不可再分。

**事务：就是批量的DML语句同时成功，或者同时失败！**

- 提交事务？commit
	- 清空事务性活动的日志文件，**将数据全部彻底持久化到数据库表中**。
	- 提交事务标志着，事务的结束。并且是一种**全部成功**的结束。

- 回滚事务？rollback
	- 将之前所有的**DML操作全部撤销**，并且清空事务性活动的日志文件。
	- 回滚事务标志着，事务的结束。并且是一种**全部失败**的结束。
	- 回滚只能回滚至上一次提交点。



### 事务的四个特性（ACID）

- A：原子性
	- 不可分割的最小单元
- C：一致性
	- 操作前后，总量不变
	- 在同一个事务当中，所有操作必须同时成功，或者同时失败
- I：隔离性
	- 多事务操作间不会相互影响
- D：持久性
	- 提交后，表中数据发生真的变化



### 事务的隔离级别

1. 读未提交 - read uncommitted （最低级）
	- 没有提交就读到了
	- 事务A可以读取到事务B未提交的数据。
2. 读已提交 - read committed
	- 提交之后才能读到
	- 事务A只能读取到事务B提交之后的数据。
	- oracle数据库默认的隔离级别是：read committed
	- 解决了脏读现象
3. 可重复读 - repeatable read
	- 提交之后也读不到，永远读取的都是刚开启事务时的数据
	- 事务A开启之后，不管是多久，每一次在事务A中读取到的数据都是一致的。即使事务B将数据已经修改，并且提交了，事务A读取到的数据还是没有发生改变，这就是可重复读。
	- 解决了不可重复读的问题
	- MySQL默认
4. 序列化/串行化 - serializable （最高级）
	- 事务排队，不能并发



#### **脏读、不可重复读、幻读**

1. 脏读
	- 一个未提交事务读取到另一个未提交事务的数据
2. 不可重复读
	- 一个未提交事务读取到了另一个提交事务**修改**的数据
	- 同样的条件，你读取过的数据，再次读取出来发现值不一样了。
3. 幻读
	- 一个未提交事务读取到另一个提交事务的**添加**（增删）数据
	- 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入（注意是插入或者删除，不是修改）了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。
	- 对InnoDB不可能

**通过设置隔离级别，解决读问题**

|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | 有   | 有         | 有   |
| 读已提交 | 无   | 有         | 有   |
| 可重复读 | 无   | 无         | 有   |
| 串行化   | 无   | 无         | 无   |

> 基本不用读未提交和串行化