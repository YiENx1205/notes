

# Http状态码

https://www.runoob.com/http/http-status-codes.html

- 1xx：信息，服务器收到请求，需要请求者继续执行操作
- 2xx：成功，操作被成功接收并处理
	- 200 - 请求成功
- 3xx：重定向，需要进一步的操作以完成请求
	- 300 - 资源（网页等）被永久转移到其它URL
- 4xx：客户端错误，请求包含语法错误或无法完成请求
	- 404 - 请求的资源（网页等）不存在
- 5xx：服务器错误，服务器在处理请求的过程中发生了错误
	- 500 - 内部服务器错误

| 状态码 | 原因 |
| ------ | ---- |
| 100    |      |



# Socket

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。**在应用层和传输层之间的一个抽象层。**在设计模式中，Socket其实就是一个门面模式，它`把复杂的TCP/IP协议族隐藏在Socket接口后面`，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

TCP/IP协议族包括运输层、网络层、链路层。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051654646.png" alt="20190718154451958" style="zoom: 67%;" />

## 一、网络进程之间如何通信

- 首要解决的问题是**如何唯一标识一个进程**，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“**ip地址**”可以唯一标识网络中的主机，而传输层的“**协议+端口**”可以唯一标识主机中的应用程序（进程）。
- 这样利用**三元组（ip地址，协议，端口）**就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
- 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。

## 二、socket的基本操作

网络中的进程是通过socket来通信的。

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用`“打开open –> 读写write/read –> 关闭close”`模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。

- socket()函数
- bind()函数
- listen()、connect()函数
- accept()函数
- read()、write()函数
- close()函数

# TCP和UDP

UDP是与TCP相对应的协议，都是是属于TCP/IP协议族中的一种。

- **TCP (Transmission Control Protocol) 传输控制协议**
	- 采用”三次握手“和”四次挥手机制“，建立TCP连接，形成传输数据通道，点对点通信，是**可靠的**
	- 在连接中可以进行**大数据量的传输**
	- 传输完毕，需要**释放已经建立的连接，效率低**
	- **面向连接**
	- 例如：电话
- **UDP (User Datagram Protocol) 用户数据报协议**
	- 每个数据报的大小限制在64K；可以广播发送
	- 发送不管对方是否收到，接收方收到也不确认，**不可靠**
	- 发送结束**无需释放资源**，**开销小**，**速度快**
	- **非面向连接**
	- 例如：短信，电报



# 输入URL后的过程

1. DNS解析成ip地址，通过ip地址找到客户端到服务器的路径
2. 建立TCP连接（三握）
3. 浏览器和服务器之间进行数据传输：浏览器发送HTTP请求，服务器响应
4. 页面渲染



# DNS解析

浏览器希望得到**域名对应的ip地址**，DNS (Domain Name System，域名系统) 负责查找，查找过程如下：

1. 浏览器缓存中查找
2. 在系统缓存中查找，找系统的DNS缓存，即hosts文件中域名与ip的映射关系
3. 如在操作系统中没有找到，则查找本地DNS服务器缓存
4. 若本地DNS服务器中没有找到，直接请求Root Server域名服务器（根域名服务器）
5. Root Server接到请求后返回给本地DNS服务器一个gTLD server(顶级域名服务器||查询域的主域名服务器)地址，仿佛再说：“本地DNS服务器，你好，我这里只能告诉你一位大神帮你解惑，他就是顶级域名服务器，快去找他吧”
6. 本地DNS服务器用Root Server返回的gTLD server地址找到gTLD server并发出解析请求
7. gTLD 服务器接受了请求，并且进行处理（查找并且返回此域名对应的Name Server），说：“发现了，这个域名对应的Name服务器（域名服务器），你去找他要IP地址吧！”
8. 本地DNS服务器向Name Server发出解析的请求，Name Server找到该域名的IP，连同一个TTL值返回给本地DNS服务器
9. 欣喜的本地DNS服务器，立马缓存该域名和IP的对应关系（去到别人家的路线图），缓存的时间由TTL的值控制，心想：“我终于要完成任务了，我的主人马上就能去到这个域名的家里做客了！我拿到了去那里的路线图”
10. 把解析结果返回给用户，用户根据TTL的值进行缓存。



![在这里插入图片描述](https://img-blog.csdnimg.cn/20200813160538205.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMjg1ODg5,size_16,color_FFFFFF,t_70#pic_center)



# 三握四挥

因为TCP是全双工，连接和断开都需要确认

## 数据包

序列号**seq**：sequence；序列号seq就是这个报文段中的第一个字节的数据编号

确认号**ack**：期待收到对方下一个报文段的第一个数据字节的序号

控制位

- **ACK**：1表示确认号有效；Acknowledge
- **SYN**：同步序号，1表示请求连接；SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。；Synchronization
- **FIN**：释放连接；Finish

## 一、三次握手
