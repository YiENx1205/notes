# 网络模型

## 一、OSI模型

`OSI`是`Open System Interconnection`，开放系统互联。

**`OSI`七层模型：**

- 7应用层(Application)：能够产生网络流量能够和用户交互的应用程序。

- 6表示层(Presentation)：数据加密压缩？ (开发人员需要考虑的问题）。

- 5会话层(Session)：服务和客户端建立的会话 (查木马 netstat -nb)。

- 4运输层(Transport): 可靠传输(建立会话)、不可靠传输(不建立会话)、流量控制。

- 3网络层(Network)：IP地址编址 选择最佳路径。

- 2数据链路层(Data Link)：数据如何封装 添加物理层地址(MAC地址)。

- 1物理层(Physical)：电压 接口标准。

程序开发人员需要考虑：应用层、表示层、会话层。

网络工程师需要考虑：运输层、网络层、数据链路层、物理层。



进行网络排错时：要从低层向高层来排错。



## 二、TCP/IP模型

**`TCP/IP`五层模型：**

- 5应用层(Appplication)：传输数据单元。

- 4运输层(Transport)：运输层报文。

- 3网络层(Network)：IP数据报(IP分组)。

- 2数据链路层(Data Link)：数据帧。

- 1物理层(Physical)：比特流011010101。

	

> TCP/IP协议通信流程

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207081548319.png" alt="TCP/IP协议发送数据流程" style="zoom:60%;" />

# Mac地址

网卡的物理地址，出厂自带，全球唯一。

局域网中的ip地址唯一，但是局域网外的可能重复。

网络通讯需要ip+mac，计算机通过**ARP协议**发送广播报文，只有相应的ip地址才会回复mac地址。

局域网中路由器通过DHCP协议分配不同的ip地址给设备。

**Mac地址是为了解决IP盗用的安全问题**

在交换机内部通过“表”的方式把MAC地址和IP地址一一对应，也就是所说的IP、MAC绑定。 

MAC地址处于链路层

# 交换机与路由器

## 一、交换机

交换机有若干端口，内部保存连接的网卡的mac与端口的对应关系，即MAC地址表。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202207081529012.png" alt="image-20220708152932145" style="zoom:50%;" />

## 二、路由器

路由器有WAN口和LAN口，

没有WAN口的话，就是个交换机

### 1、网关

连接两个子网

路由器也相当于一个网关

# Http状态码

https://www.runoob.com/http/http-status-codes.html

- 1xx：信息，服务器收到请求，需要请求者继续执行操作
- 2xx：成功，操作被成功接收并处理
	- 200 - 请求成功
- 3xx：重定向，需要进一步的操作以完成请求
	- 300 - 资源（网页等）被永久转移到其它URL
- 4xx：客户端错误，请求包含语法错误或无法完成请求
	
	- 403 - 请求被拒绝
	- 404 - 请求的资源（网页等）不存在
- 5xx：服务器错误，服务器在处理请求的过程中发生了错误
	- 500 - 服务器正在执行请求时发生错误
	- 503 - 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

# Socket

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。**在应用层和传输层之间的一个抽象层。**在设计模式中，Socket其实就是一个门面模式，它`把复杂的TCP/IP协议族隐藏在Socket接口后面`，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

- `网络上具有唯一标识的IP地址和端口号组合在一起构成唯一能识别的标识符套接字`
- 网络通信就是socket间的通信
- socket允许程序把网络连接当成一个流，数据在两个socket间通过IO传输
- 分类
	- 流套接字（stream socket）：使用TCP提供可依赖的字节流服务
	- 数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务

TCP/IP协议族包括运输层、网络层、链路层。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051654646.png" alt="20190718154451958" style="zoom: 67%;" />

## 一、网络进程之间如何通信

- 首要解决的问题是**如何唯一标识一个进程**，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“**ip地址**”可以唯一标识网络中的主机，而传输层的“**协议+端口**”可以唯一标识主机中的应用程序（进程）。
- 这样利用**三元组（ip地址，协议，端口）**就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
- 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。

## 二、socket的基本操作

网络中的进程是通过socket来通信的。

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用`“打开open –> 读写write/read –> 关闭close”`模式来操作。Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。

- socket()函数
- bind()函数
- listen()、connect()函数
- accept()函数
- read()、write()函数
- close()函数

<br>

# TCP和UDP

UDP是与TCP相对应的协议，都是是属于TCP/IP协议族中的一种。

- **TCP (Transmission Control Protocol) 传输控制协议**
	- 采用”三次握手“和”四次挥手机制“，建立TCP连接，形成传输数据通道，点对点通信，是**可靠的**
	- 在连接中可以进行**大数据量的传输**
	- 传输完毕，需要**释放已经建立的连接，效率低**
	- **面向连接**
	- 例如：电话
- **UDP (User Datagram Protocol) 用户数据报协议**
	- 每个数据报的大小限制在64K；可以广播发送
	- 发送不管对方是否收到，接收方收到也不确认，**不可靠**
	- 发送结束**无需释放资源**，**开销小**，**速度快**
	- **非面向连接**
	- 例如：短信，电报

<br>

# Http与Https

http：

- 无加密、明文 
- —> 应用层

- 端口80

https：

- s【TLS标准，基于SSL(TLS前身)的加密协议】
- SSL在应用层和传输层之间加上了安全层
- —> 应用层 + 安全层
- 端口443

## 一、对称加密和非对称加密

### 1、对称加密

加密和解密是同一把密钥

### 2、非对称加密

加密和解密使用不同的密钥

分公钥和私钥；使用公钥加密，则只能使用对应的私钥解密，私钥可以推出公钥，反之不行

SSL证书：保存在源服务器的数据文件，需向CA（Certificate Authority）申请，证书中包含公钥和私钥

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061011366.PNG" />

公钥是传输的，私钥不传输，这样就算小黑想要窃取密文，也没有对应的密钥解开

## 二、https的加密 — 对称与非对称共用

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204061016767.PNG" alt="IMG_1017 2" style="zoom:80%;" />

预设主密钥：用公钥加密后的随机数

使用会话密钥进行对称加密传输

> 传输对称加密的密钥（会话密钥）使用非对称加密
>
> 传输数据使用对称加密

## 三、认证

通过使用   **证书**   来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202205011121645.png" width="" style="zoom:67%;" />

## 四、http1和http2

### 1、http1的缺陷

- 网络延迟问题主要由于队头阻塞(Head-Of-Line Blocking)，导致带宽无法被充分利用。

> 队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。

- 明文传输
- header中的固定字段会带来极大开销

### 2、区别

与HTTP 1.1相比，主要区别包括

a>HTTP/2采用**二进制格式**而非文本格式

b>HTTP/2是**完全多路复用**的，而非有序并阻塞的——只需一个连接即可实现并行

> 多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。

c>使用**报头压缩**，HTTP/2降低了开销

> 在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串

d>HTTP/2让服务器可以将响应**主动“推送”**到客户端缓存中

> HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）

### 3、纯文本和二进制格式

ASCII模式（文本传输）和BINARY模式（二进制传输）

> 区别是回车换行的处理，binary方式不对数据执行任何处理，ASCII 方式将回车换行转换为本机的回车字符，比如Unix下 是\n,Windows下是\r\n，Mac下是\r

http1的文本格式是指它的请求头、响应头，分隔符等都是以文本方式传输的。

> 无符号数字123，用二进制的方式是直接发送一个字节，该字节内容是123。用纯文本的方式需要发送三个字节，内容是49 50 51，接收方收到之后可以解析为字符串`123`，在根据字符串`123`转为数字123



<br>

# 输入URL后的过程

1. DNS解析成ip地址，通过ip地址找到客户端到服务器的路径
2. 建立TCP连接（三握）
3. 浏览器和服务器之间进行数据传输：浏览器发送HTTP请求，服务器响应

> 还可以详细描述，服务器收到请求后，根据指定端口，将请求传递给绑定了该端口的应用程序，比如8080的tomcat；
>
> 收到请求后，解析得到需要访问的servlet，然后MVC的DispatcherServlet，Controller；
>
> tomcat得到相应后封装成http响应的格式，发送给浏览器所在的服务器。

4. 浏览器页面渲染



# DNS解析

浏览器希望得到**域名对应的ip地址**，DNS (Domain Name System，域名系统) 负责查找，查找过程如下：

1. 浏览器缓存中查找
2. 在系统缓存中查找，找系统的DNS缓存，即hosts文件中域名与ip的映射关系
3. 如在操作系统中没有找到，则查找本地DNS服务器缓存
4. 若本地DNS服务器中没有找到，直接请求Root Server域名服务器（根域名服务器）
5. Root Server接到请求后返回给本地DNS服务器一个gTLD server(顶级域名服务器||查询域的主域名服务器)地址
6. 本地DNS服务器用Root Server返回的gTLD server地址找到gTLD server并发出解析请求
7. gTLD 服务器接受了请求，并且进行处理（查找并且返回此域名对应的Name Server），说：“发现了，这个域名对应的Name服务器（域名服务器），你去找他要IP地址吧！”
8. 本地DNS服务器向Name Server发出解析的请求，Name Server找到该域名的IP，连同一个TTL值返回给本地DNS服务器
9. 欣喜的本地DNS服务器，立马缓存该域名和IP的对应关系（去到别人家的路线图），缓存的时间由TTL的值控制，心想：“我终于要完成任务了，我的主人马上就能去到这个域名的家里做客了！我拿到了去那里的路线图”
10. 把解析结果返回给用户，用户根据TTL的值进行缓存。



<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204060943604.png" alt="iShot2022-04-06_09.42.36" style="zoom:50%;" />

根域名服务器：.（root会省略，就是个点了）

顶级域名服务器gTLD：generic Top Level Domain

- com、cn、net、...

# 三握四挥

因为TCP是全双工，连接和断开都需要确认

## 数据包

序列号**seq**：sequence；序列号seq就是这个报文段中的第一个字节的数据编号

确认号**ack**：期待收到对方下一个报文段的第一个数据字节的序号

控制位

- URG：紧急指针是否有效。为1，表示某一位需要被优先处理
- **ACK**：1表示确认号有效；Acknowledge
- PSH：提示接收端应用程序立即从TCP缓冲区把数据读走。
- RST：对方要求重新建立连接，复位。
- **SYN**：同步序号，1表示请求连接；SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。；Synchronization
- **FIN**：释放连接；Finish

PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。

## 一、三次握手

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051742823.png" alt="0E9867A3C4B032B2E9EA1AEA39867481" />

- **第一次握手**：建立连接时，客户端发送SYN包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；

- **第二次握手**：服务器收到SYN包，必须确认客户的syn（使用ack=x+1，x为客户的syn），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RCVD状态；

- **第三次握手**：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTAB-LISHED（TCP连接成功）状态，完成三次握手。

## 二、四次挥手

<img src="https://cdn.jsdelivr.net/gh/YiENx1205/cloudimgs/notes/202204051743057.png" alt="8EA876AC055FE582FBA4C7631E87A883"/>

四次挥手由于TCP的半关闭造成的，因为TCP是全双工，所以关闭时要双向都关闭，单方向的关闭叫做半关闭。

- **客户端进程发出连接释放报文，并且停止发送数据**：客户端发送FIN，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1）。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- **服务器收到连接释放报文，发出确认报文**，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器可能依旧有数据没有发送完毕。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- **客户端收到服务器的确认请求**后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）
- **服务器将最后的数据发送完毕后，就向客户端发送连接释放报文**，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- **客户端收到服务器的连接释放报文后，发出确认**，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 常见问题

### 1、为什么连接的时候是三次握手，关闭的时候却是四次握手？

连接时，客户端发送请求后，服务器可以直接发送SYN+ACK报文。但是关闭时，当服务器发送FIN后，服务器可能还有未发送完的数据，此时只能先发送一个ACK报文进行确认，等传输完成后，才会发送FIN报文。

### 2、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

虽然按道理，四个报文都发送完毕，可以直接进入CLOSE状态了，但是**必须假想网络是不可靠的**，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来**重发可能丢失的ACK报文**。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### 3、为什么不能用两次握手进行连接？

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的，还可能浪费资源。

#### 例子一

考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据。

可是，在S的应答在传输中被丢失的情况下，C将不知道S是否已准备好，甚至怀疑S是否收到自己的连接请求。

在这种情况下，**C认为连接还未建立成功**，**将忽略S发来的任何数据**，只等待连接确认应答。而S在发出的报文段超时后，重复发送同样的报文段。这样就形成了死锁。

#### 例子二

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。

数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，**但是第一个丢失的报文段只是在某些网络结点长时间滞留了**，**延误到连接释放以后的某个时间才到达服务端**。

此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接。

不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。


### 4、如果已经建立了连接，但是客户端突然出现故障了怎么办？

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
